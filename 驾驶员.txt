桃源        张村        高庙       瓦屋山
田永祥50832 张登祥38079 张登祥38005 55963
雷秀勇55319 张登祥38068      38078
马国祥55202 王大  50863      23782
---------- 王小车27378      55968
柳江        李淑容37622
56733
56912
56963
38058


           洪雅旅客运价表
|----------------------------------------
|    | 洪雅         |     | 洪雅17
|止戈 | 道泉茶厂2    |止戈  | 安子场16
|（4） | 岩嘴庙3      |（15）| 岩嘴庙15
|    |             |     | 百花滩
|    | 止戈         |     | 止戈
|-2  | 花溪口未过桥4 | -2  | 
|----|-------------|-----|------------
|东岳 | 团结小学5    |     | 花溪口未过桥14
|（7） |             |东岳  | 漫水桥13
|    | 踏水桥6      |     | 踏水桥
|    |              |（13）| 新民派出所
|    | 东岳         |     | 东岳
|-2  | 石谷包7       |     | 石包谷12
|    |              |-4   | 张沟路口11     
|----|--------------|-----|---------
|    |              |     | 杨岩桥
|花溪 | 机砖厂8       |花溪 | 机砖厂
|    |              |     | 白土坪
|（9） | 花溪         |（10）| 花溪
|    | 孔坝大桥9     |     | 孔坝大桥
|    |              | -7  | 大柳坝10
|----|--------------|-----|---------
|    |              |     | 老交警队9
|柳江 | 柳江         |柳江  | 柳江
|（10）| 李湾口大桥10  |（9） | 李湾口大桥
|-----|-------------|-----|---------
|赵河 |             |赵河  | 姜湾坡8
|     | 洪江桥11    |      | 洪江桥
|（14）| 三溪水12     |（5）  | 三溪水7
|     |             |     | 道班房6
|-7   | 石板沟13     |     | 石板沟
|     | 赵河         |-12  | 赵河5
|     | 香花岗14     |     | 香花岗4
|-----|-------------|------|---------
|高庙  |             |高庙  | 郭守义3
|     | 余沟15       |     | 余沟
|（17） |             |     | 调度山2
|     |  双河口16    |      |双河口
|     | 安溪沟       |     | 安溪沟
|-12  | 高庙17       |     | 高庙
|-----|-------------|------|--------
|张杜  | 曾田坝
|     | 白店子
|（19） | 漆树湾
|      | 糟包坪
|      | 张村
|-----------------------------------


张村 <-> 洪雅（19元70公里0.27/公里17方气50元）
   1张村   2洪雅   3张村   4洪雅
1  6：10    9：50  12：40  15：50
2  6：50   11：50  14：50
3  7：30   13：00
4  8：10   14：00


洪雅 <-> 张村
   1洪雅   2张村   3洪雅
1  8：10   10：50  14：50
-----------------------------
止戈4
东岳7 
花溪9
柳江10
赵河13
高庙15
张村19 
-----------------------------
洪雅-槽渔滩（8元/25公里0.32/公里5.5方气15元）

止戈花溪口大桥4
团结园水井5
塔水桥6
新明7
白坳口8
新明-罗坝5
渡槽4
毛沟3
徐嘴2


   1     2    3      4     5    6
1 6：30 8：30 10：20 12：10 2：20 5：20 
2 7：00 8：55 10：45 12：40 2：45 4：00
3 7：30 9：20 11：10 1：20  3：10 4：20
4 8：10 9：55 11：40 1：55  3：40 4：40


   1     2    3      4     5    6
             9：40
1 6：30 8：30 10：30 12：25 1：55 4：00 5：20
2 7：00 8：55 10：55 1：20  2：40 4：00
             11：10
3 7：30 9：20 11：30 1：40  3：10 4：20
4 8：10 9：55 11：55 2：00  3：40 4：40

-----------------------------------

人工费 驾驶员4000月       4000
      售票员1700月       1700
油费   107天x30          3210
折旧费 330000／8年／12月  3437.5
维修费 二保500季/3         166.7
      打黄油20季/3          6.7
年审   气瓶500个x4/24      83.4
      车管400年/12        33.4
      综检400年/12        33.4
税    保险10000年/12      833.4
      管理费 800月        800
gps   1050年/12           87.5
 
合计 14392.3月 479.8天

43272.0-43104.9=168
96/168=0.58元/公里
33/168=0.2m3/公里

44375.3-44212.7 =162.6 
 
----------------------

------客车驾驶----------
离合器最佳高度为3个指头
    客车驾驶看路人
    鸣喇靠近多提醒
    节假民俗知客源
    班次时间抢客源
    提前挂档开关门
    节约时间要安全    
    开门首先门无人
    监控提醒才开门
    
    关门首先门无人
    监控后镜才关门
   


--------------------    
   
       行车守则

    行车首先把路看
    看远估近定轮位
    提前预见勤修正
    两耳随时动机听
    根据声音档速变
    平稳节能记安全
    遇事减速心不慌
    避人保物稳方向

    随时注意有无超
    眼耳后镜知八方
    仪表路标不忘掉
    车况路况早知道
    
    路标一定仔细看
    知位定路确方向
    路口选道看路标
    减速停车左右观
    障碍减速仔细看
    骑挂躲让定轮位
    
    节能操作常滑行
    经济时速小油门
    少用低档早挂高
    提前预见车少停
    
    平缓空滑陡带档
    冲车带档常丢油
               
    错走莫慌前调头
    下一出口桥下找

    左脚正对定左轮    
    车中三点估右轮 
    估右定左不忘高
    需要哪边定哪边
    门角正对保险杠
    后镜轮眉定轮尾

    倒车首先侧后看
    左右安全才起步
    后镜轮眉定轮位
    观后不忘前轮位
        
    跟车首先保车距
    跟据路况早预见

    超车首先侧后看
    打向闪灯喇叭按
    车前三点定轮位
    加速超车后镜看
    打向慢回转向关
    弯道禁超保安全
    
    会车首先定轮位
    定右挂左稳方向
    变灯按喇稳速度
    
       上车
    上车首先四周看
    车货轮胎油水量
    确认安全左手开
    左扶踩踏跨入内
    左脚收入顺关门
    踩离到底调椅背
    镜内见路见车体
       姿势
    左十右三握方向
    紧靠背椅远方看
    左脚常放离左下
    右脚放在油门上 
    不许下看盲控制
    离合操作快停慢
    车动丢离油平缓

    发动首先踩制动
    踩离拉刹档杆晃
    加油发动五秒停
    高低转速要正常
       技1
    起步首先挂低档
    打向鸣喇后镜看
    侧后安全手刹松
    加油抬离听声音
    音变车斗稍一停
    松开制动跟油门
    慢抬离合车前进
    车动丢离转向回
    起步困难半离合
    加油慢抬巧配合       
       技2
    加档首先把车冲
    听声加油看车速
    声音速度都提高
    踩离松油同挂空
    抬离再踩加一档
    加油抬离半联停
    加油慢抬要平稳
 
    减档首先听声音
    加油看速估动力
    声闷速降带不起
    踩离松油同挂空
    抬离不忘空油上
    踩离减档看车速
    加油稍大半联停
    慢抬加油动力足
    
    加速随时备加档
    减速必须减一档
    加档必须逐级加
    减档越级看车速
       技3
    转弯首先侧后看
    减速打向喇叭按
    靠右慢进定轮位
    以后定前取角度
    侧身平衡挂侧后
    侧后安全加速度
    慢进快出记心田
    三把方向把路变
    甩头回正回方向
    早打早回提前量
    跟据速度转快慢
       技4
    减速首先松油门
    轻重踩刹看车速
    一踩一稳降速度
    速降踩离把速稳
    慢抬停车惯性稳
       技5
    停车靠边先选位
    打向减速侧后看
    踩离挂空调速度
    安全靠边定轮位  
    回正车身后镜看
    踩离停车同回向
    拉紧手刹才媳火
    驻档抬离松制动

    下车首先取钥匙
    侧后安全半开门
    左扶踩踏取物品
    摇窗关紧锁好门
    车货轮胎查安全
    垫好轮胎人才离
===================================
网上预约
http://sc.122.gov.cn/
身份证号
ig79oz09~ 
===================================

﻿   1米  2米  3米   4米  5米  6米

 4 0017 0041 0073 0113 0186 0224

 6 0035 0079 0134 0201 0280 0373

 8 006  013  021  031  043  056

10 009  019  031  045  061  078

12 013  027  043  062  082  105

14 017  036  058  083  111  142

16 022  047  075  106  141  179

18 027  059  093  132  174  219

20 034  072  114  160  210  264

22 041  086  137  191  250  313

24 048  102  161  225  293  366

26 057  120  188  262  340  423

28 066  138  217  302  391  484

30 075  158  248  344  444  549

==================================

  7米   8米   9米  10米 

 4 0297 0382 0481 0594 
 
 6 0481 0603 0743 0899 

 8 071  087  106  127  

10 098  120  144  170

12 130  157  187  219

==================================

3米6 周长/7x2=直径＆(周长-34)/35=直径

4米10 不能降锯短 先看弯端再搰大小

5米14          先摸圆扁再下锯

6米14          锯斜不锯正

==================================

  1.5米 2.2米 4.2米 4.4米

 4 0027 0047 0122 0132

 6 0055 0089 0216 0231

 8 009  015  034  036

10 014  022  048  051

12 020  030  065  069

14 026  040  089  094 

16 032  052  113  120

18 042  065  140  148

20 052  080  170  180

22 062  096  203  214

24 074  114  239  252

26 086  133  277  293

28 099  154  319  337

30 113  176  364  383

=================================

孙子兵法
五事七计知型势
利害五危辨虚实
诈利分合争易胜
弱守强攻以少胜
====================================
排行
少，文，忠，
====================================
A1大型客车：车长>6米，核载=>20人
A2牵引车
A3公交车
B1中型客车：车长<6米，核载10-19
B2大型货车：车长>总质量12吨
C1
C2
C3
C4
D
E
F
  中型货车
  小型客车：车长<6米，核载<9
  微型客车：车长<3.5米，排量<1升 
===================================
淘(支付)宝 /lizhongquan008@163.com
手银      \13548248078
密码      /ig**oz**
         \l**hon**uan
图吧 SESP-XYBZ-35KZ-5NQA 
mspsbc3
太平洋网吧8个6
http://www.rayfile.com/files/2a27c42b-f48e-11e0-ba78-0015c55db73d/ http://www.cnblogs.com/ 
 http://down.51cto.com/ 
lzqwsqm 19790209
 http://www.pudn.com/
==================================
DG8FV-B9TKY-FRT9J-6CRCC-XPQ4G

MSDN Windows XP Professional With Sp3 Vol
卷标:GRTMPVOL_CN
大小:630237184 字节
MD5:E74D72F3D90456003E9E02BA0FB7DA61
SHA1:D142469D0C3953D8E4A6A490A58052EF52837F0F
CRC32:FFFFFFFF
下载地址:http://yuner.qupan.com/2107946.html

1、制作U盘启动盘（小马）
2、进入dos，fdisK分区
   A.do you wish to enable large disk support[Y/N]问是否支持大硬盘输入Y
     
    **硬盘分区的原则是∶先创建主分区，再创建扩展分区，将扩展分区分为N个逻辑分区最后设置活动分区**。
   
   B.如有多个硬盘输入5选择要分区的硬盘
   C.1. create dos pratition or logical dos drive创建分区输入1 
     create primar dos partition创建主分区verfying drove integrity,0% complete等待扫描进度do you wish to use the maximum available size for a primary dos partition and make the partition active是否将全部硬盘空间分配给主分区输入N
   D.verfying drove integrity,0%complete等待扫描进度enter partition size inmbytes or percent of disk space(%)to creare aprimary dos patition输入准备分配给主分区的容量，可输入大小***MB，也可用%输入 press esc to cintinue按“Esc”键退回主菜单
   E.输入1创建分区输入2 create extemded dos partition创建扩展分区enter partition size in mbytes or percent of disk dpace(%)to creare an extended dos partition输入准备分配给扩展分区的容量，可输入大小 ***MB，也可用%输入。因为硬盘上只能有主分区(最多可设4个)、扩展分区(      逻辑分区在扩展分区里)和空闲空间(即未分配空间)三种，如果不将除主分区之外的所有硬盘容量分配给扩展分区，就会产生无用的空闲空间做成浪费 ，因此这里标示出来的容量不能更改，直接按Enter回车键后press esc to cintinue按“Esc”键退回主菜
   F.No logical drivcs fcgoncd提示没有逻辑分区输verfying drove integrity,0% complete等待扫描进度enter partition size in mbytes or percent of disk space(%)to creare an extended dos partition输入准备分配给逻辑分区的容量，可输入大小***MB，也可用%输入。。。。all availablc space in the Extcndcd DOS partition is assigncd to logical drivcs提示全部扩展分区容量分配完按“Esc”键退回主菜
   G.输入2设置活动分区，输入1选择C盘，按“Esc”键退回主菜，按“Esc”键 退出FDISK提示要重新启动系统使设置生效，所有更改的分区在重启后格式化才能使用，按“Esc”键退出，按“R”键或（Ctrl+Alt+Delete）重启
3、格式化 Format x:(x为盘符，系统安装盘必须格式化)
4、进入WinPE拷贝安装文件
5、进入dos
6、x:回车进入各盘。dir x:查看各盘。找出系统（C)盘和安装文件夹I386各在哪个盘
7、format x:格式化系统盘
8、回Dos盘letassig /M x:=C: C:=x:纠正c盘符错乱
9、进入安装文件夹盘smartdrv直到有反应
10、cd i386进入文件夹
11、winnt按照提示操作
12、设置电脑
   A、右击任务栏，点击属性。任务栏下取消分组相似任务栏按钮，选择显示快速启动。[开始]菜单下选择经典[开始]菜单。点应用，点确定。
   B、右击桌面，点击设置。屏幕分辨率为1024x768.
   C、右击我的电脑，点击属性，环境变量。xxx用户变量与系统变量分别将TEMP、TMP编辑到D:\Temp或其它盘。点确定。
   D、右击我的文档，点击属性。目标文件夹编辑到D或其它盘。点应用，点确定。
   E、左双击打开我的文档，点工具，文件夹选项，查看。高级设置中取消隐藏已知文件类型的扩展名。点应用，点确定。
   F、右击Internet Explorer属性,Internet临时文件中点设置点移动文件夹选择D或其它盘。点确定。
   G、右击网上邻居，点击属性。创建一个新的连接；连接到Internet；手动设置我的连接；用拨号调制解调器连接（调制解调器选择moto的那个就对了）；ISP输入defy；电话号码输入*99#；用户名密码不填，其于选项不勾选；选择在我的桌面上添加一个到止连接的快捷方式点完成后拨号，会出现拨号成功了（1、准备MOTO的驱动，就是那个motohelper的USB驱动,检查设备管理器中调制解调器有moto USB Modem.2、USB线连接手机,选择摩托罗拉门户方式.手机上网接入点选择3gnet，移动的话就用cmnet.3、电脑上查       看网络连接应该有很多本地连接之类的。应该有一个本地连接为Motorola USB Networking Driver，这个说明驱动正常。）
   H、将以下内容复制成 清除系统垃圾.bat 并运行。
-----------------------------------------------------------------
del /s/f/q "D:\Temp\*.*" 
rd /s /q "%windir%\temp" 
rd /s /q "%userprofile%\Local Settings\temp" 
del /s/f/q "D:\Temporary Internet Files\*.*" 
rd /s /q "%userprofile%\Local Settings\Temporary Internet Files" 
del /f /q %systemdrive%\*.tmp 
del /f /q %systemdrive%\*._mp 
del /f /q %systemdrive%\*.log 
del /f /q %systemdrive%\*.gid 
del /f /q %systemdrive%\*.chk 
del /f /q %systemdrive%\*.old 
del /a /f /q %systemdrive%\Recycler\*.* 
del /f /q "%ALLUSERSPROFILE%\Documents\DrWatson\*.*" 
del /f /q "%USERPROFILE%\Application Data\Microsoft\Office\Recent\*.lnk" 
del /a /f /s /q "%systemroot%\temp\*.*" 
del /a /f /s /q "%systemroot%\Prefetch\*.*" 
del /f /q /s /a "%systemroot%\minidump\*.*" 
del /a /f /s /q "%systemroot%\*.log" 
del /a /f /s /q "%systemroot%\*.dmp" 
del /a /f /s /q "%systemroot%\*.tmp" 
del /a /f /s /q "%systemroot%\*._mp" 
del /a /f /s /q "%systemroot%\*.gid" 
del /a /f /s /q "%systemroot%\*.bak" 
del /a /f /s /q "%systemroot%\*.old" 
del /a /f /s /q "%systemroot%\*.query" 
for /d %%a in ("%systemroot%\$*$") do rd /s /q "%%a" 
reg query "HKCU\software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" /v Cache>%temp%\cleantmp.txt 
reg query "HKCU\software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" /v Cookies>>%temp%\cleantmp.txt 
reg query "HKCU\software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" /v History>>%temp%\cleantmp.txt 
reg query "HKCU\software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" /v NetHood>>%temp%\cleantmp.txt 
reg query "HKCU\software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" /v Recent>>%temp%\cleantmp.txt 
for /f "tokens=3*" %%a in (%temp%\cleantmp.txt) do ( 
	for /d %%i in ("%%a %%b\*.*") do rd /s /q "%%i" 
	del /a /f /s /q "%%a %%b\*.*" 
) 

echo. 
for /l %%i in (1,1,30000) do @echo %%i  
---------------------------------------------------------------------
安装文件工具wrar390sc.exe、uiso9_cn.exe

12.安装主板芯片组驱动。
13.安装DirectX驱动
14.安装显卡驱动
15.安装声卡网卡等插在主板上的其他设备驱动。
16.安装打印机、扫描仪等其他外设驱动。
17.安装组件
18.安装应用软件

Windows XP pro零售版，安装后必须在30天内联网激活。

工行密钥：MRX3F-47B9T-2487J-KWKMF-RPWBY，

安装时请输入。工行密钥虽然出来已经很长时间了，但是仍然可以正常激活并通过验证，系统运行很流畅，建议大家使用。

关于VOL 和 VLK 解析——  VOL是Volume Licensing for organizations 的简称，中文即“团体批量许可证”。根据这个许可，当企业或者政府需要大量购买微软操作系统时可以获得优惠。这种产品的光盘卷标带有"VOL"字样，就取"Volume"前3个字母，以表明是批量。这种版本根据购买数量等又细分为“开放式许可证”(Open License)、“选择式许可证(Select License)”、“企业协议(Enterprise Agreement)”、“学术教育许可证(Academic Volume Licensing)”等5种版本。根据VOL计划规定， VOL产品是不需要激活的。
  VLK不是一种独立版本。VLK的全称是Volume Licensing Key ，它是指VOL版本在部署(deploy)中所需要的 KEY，而且只能用于VOL版中。简而言之，对VOL版XP来说，VLK就是PID为640的安装 KEY 。例如，上海市政府VOL版XP所带的安装

KEY：DG8FV-B9TKY-FRT9J-6CRCC-XPQ4G

就是一个VLK。VLK的作用仅仅是证明产品合法化。按照许可协议，零售版XP的“密钥”只能用在一台PC上，而 VOL 版XP则可按协议供给多台PC使用。还有一个重要的区别，零售版XP需要激活，而 VOL 版XP根本就没有这个概念。VOL版的XP没有Home这个版本，其功能跟 Professional版是一样的。

====================================
我们立足于美利坚合众国，对全球华人服务，受北美法律保护。版权所有，未经授权禁止建立镜像。未满18岁或被误导来到这里，请立即离开
 
========场地考========================
准备：
坐上车看左右后视镜能否看到后轮
看左右前视镜能否看到车前角和雨刮器座
将坐橙调到最前系上安全带
举左手照像
听到语音开始
打左转向
数123（防不能感应）
挂档
松手刹
加油抬离合松刹车起步（防熄火溜车）
调速度


倒桩：
右脚踩着白线直走
过了黄色虚线停
挂倒档
加油抬离合松刹车起步
调速度
看左后镜直倒
看黄色底线刚要到仪表盘边时打死方向
看右后镜车身与中杆要小于两手掌时回一圈方向打死
车入库要正时回方向回正
看中后杆使车身与杆一手掌宽直倒
看左边紫花对着小草踩人对着时停
打一圈方向
挂1档
加油抬离合松刹车起步打死方向人到中线回死方向
车到中前杆停
打死方向
挂倒档
加油抬离合松刹车起步看左后镜调速度
当车尾看到后中杆回方向一圈再回一圈
车正回正看左边紫花对着小草踩人对着时停
打一圈方向
挂1档
加油起步调速速度使车对着库中间走
要到中杆时向中杆靠同时踩停
打一圈方向看左右后边的距离
挂倒档
加油起步调速度看左库边回方向
看中杆使后镜不要擦着杆出去看下左右两边距离
仪表盘边缘离黄色底线有两手常宽时打死方向
看远方估计车要正时回正停。
二倒同上只要后镜入库停



侧方停车：
车中出风口对着边线直走
看后镜使车离边线一手掌宽
挂倒档
加油抬离合松刹车起步调速度要慢
看右后镜直倒
看左边地面井盖底刚到门柱时打死方向
看右后镜车尾对到库角时回一圈半
看左后镜车尾对到第二根虚线回一圈
看右前视镜车前角玻璃边对到库角打死方向
车正停同时回一圈方向
打左转向
打死方向
数12345
加油起步调速度
看左边线车顺着走
看右后镜使车不压库角



单边桥：
左脚正对左桥将车摆正
要上桥时看左前镜使车身刚盖桥走
看不到桥时看远方
看两桥二分之一使车直线行驶
到中点后打一圈连四分之一方向即在手在上
右脚对到桥时回二圈连四分之一即右手在上
看远方车要正时回方向使出风口边顺着桥外侧走
看右前镜使车身盖着桥走
后同左桥


直角转弯：
车中出风口对着边线走
看右后镜修方向
看左边直角刚过车门中点打死方向
看左后镜使车不压直角



起伏路：压饼：限宽门：
车靠左边一档怠速通过
后轮刚过车往左边靠行驶
估计车与12号饼成一线时回方向回正
右脚对着饼的中间偏右直走
靠边同时看第三饼
当第三饼离仪表盘边二手掌宽打二圈（死）方向
估计饼中心到右脚时回二圈回正
直走靠边同时看第四饼
当第四饼离窗底边一手掌宽打二圈（死）方向
右脚对着饼的中间回二圈方向回正直走靠边同时看第五饼
当门角对着饼时打二圈（死）方向 
估计饼中心到右脚时回二圈回正直走靠边同时看第六饼 
当第六饼离窗底边一手掌宽打方向
右脚对着饼边回二圈方向回正直走二钞往左边靠
看右后镜
车正加油到底
看左限宽门使后镜挨着不擦到门走
看后镜杆到车中打方向摆车
后同



坡道起步：

左脚对着停字人旁哪竖直行
调速度看到杆刚要到后镜踩离合踩停使杆刚挨着窗角
打转向
拉手刹
加油
抬离合
声音变稳离合
松手刹
加油
车不动松一点点离合



模拟雨雾、湿滑：
左手雨刮右手应急雾灯
听到语音
开雨刮（往下拉）同时开应急雾灯
加点油稳到
听到雨音松油
车头刚到最后喷水器关雨刮同时关应急雾灯



隧道：
左手喇叭右手大灯
听到语音开灯同时按喇叭时间长点
车头到标识牌
关灯按喇叭

山区：
听到语音按喇叭时间长点
加点油

调头：
车中出风口对到边线直行
听到语音打死方向
看左边底线要到门柱踩停
打死方向
挂倒档
加油抬离合松刹车起步调速度
看右边后镜
看左边底线刚到窗底线踩停
打死方向
挂1档
加油抬离合松刹车起步调速度
看右边底线要到椅背时踩停
打死方向
挂倒档
加油抬离合松刹车起步调速度
看左边后镜
看底线刚到仪表盘中间踩停
打死方向
挂1档
加油抬离合松刹车起步调速度出去


曲线：
将车正对着入口摆正靠中进入
右外边线刚到仪表盘中间时打一圈
 看左后镜慢打方向使左边线与车身一手掌宽
看右边线在仪表盘的位置保持  
看左后镜车身边线距离修方向保持一手掌宽
左边线要到左脚时打方向
看左前镜使左边线顺着雨刮器座走
看右后镜使左边线与车身一手掌宽
看雨刮器座看右后镜
保持

高速：故障：
听到语音将车停到收费站杆后不要超过杆
挂二档起步
加三档稳油门
听到语音加油到底
人过100标识牌丢油门稳油门
听到语音打右转向
数123
进库摆正踩停
拉手刹
打应急 
摘档
解安全
开门
头伸出去缩回
关门
系安全
关应急
打转向
数123
挂档
松手刹
加油起步
========路考=========================
准备：
上车将身份交给考官，
考官将身份证还给你下车，
往后绕车一圈后上车，
调后镜椅橙后镱，
系安全带，

脚放在离合不要超过去10秒
过路口不要超20码
打转向手一直扶着


起步：
打转向
挂二档
松手刹
加油抬离合松刹车起步

直线行驶：
稳方向只能小修

会车：
松油门向右打半圈回一圈

通过过路口左转弯：
松油门

加减档：

超车：

调头：
往前走点一次转过左手扶着转向开关

通过路口：

减速通过

通过学校区域：
减速通过

靠边停车：
看前视镜
车边盖线或留点空隙
=====================


汽车驾驶节能操作规范

发布日期：2017-09-13 文章来源：江苏交通学习网

江苏省质量技术监督局 发布

前  言

本标准是对JT/T807-2011《汽车驾驶节能操作规范》的完善与补充, 与JT/T807-2011相比，增加了“怠速、空挡滑行和带挡滑行”的定义、特殊道路驾驶节能操作要求、客车驾驶节能附加操作规范、货车驾驶节能附加操作规范等内容，修改了出车前检查、发动机起动、车速控制等条款。

本标准按照GB/T 1.1-2009《标准化工作导则  第1部分：标准的结构和编写》给出的规则起草。

本标准由江苏省交通运输厅运输管理局提出并归口。

本标准起草单位：江苏省交通运输厅运输管理局、交通运输部公路科学研究院。

本标准主要起草人：汪学君、蔡凤田、殷国祥、顾敏、刘莉、曾诚、钟田堂、俞伟民、李训东、万俊、阳冬波。

汽车驾驶节能操作规范

1　范围

本标准规定了汽车驾驶节能操作的术语和定义、汽车驾驶节能通用操作规范、客车驾驶节能附加操作规范、货车驾驶节能附加操作规范。

本标准适用于汽油、柴油发动机汽车的驾驶节能操作。

2　规范性引用文件

下列文件对于本文件的应用是必不可少的。凡是注日期的引用文件，仅所注日期的版本适用于本文件。凡是不注日期的引用文件，其最新版本（包括所有的修改单）适用于本文件。

GB/T 18344   汽车维护、检测、诊断技术规范

3　术语和定义

下列术语和定义适用于本文件。

3.1

常温起动  Room temperature start

环境温度高于5℃且发动机冷却液温度低于40℃时起动发动机。

3.2

热起动  Hot start

发动机冷却液温度在40℃以上起动发动机。

3.3

冷起动  Cold start

发动机冷却液温度低于5℃时起动发动机。

3.4

半联动  Semi-linkage

离合器不稳定接合的工作状态，即驾驶人松抬离合器踏板，使离合器主动盘与从动盘接合并处于相对滑动的状态。

3.5

怠速  Idle speed

变速器操纵杆置于空挡位置，完全松抬加速踏板，发动机对外无功率输出并能保持较低转速的稳定工况。

3.6

空挡滑行  Gliding in neutral

在汽车行驶中，驾驶人完全松抬加速踏板，将变速器操纵杆置于空挡位置，发动机与传动系统分离，利用车辆惯性行驶的运行状态。

3.7

带挡滑行  Gliding with transmission in gear

在汽车行驶中，驾驶人完全松抬加速踏板，将变速器操纵杆置于某前进挡位，发动机与传动系统保持接合，利用车辆惯性行驶的运行状态。

4　汽车驾驶节能通用操作规范

4.1　行车前准备

4.1.1　情绪调整

暂不考虑对情绪有较大刺激的事情，调整情绪处于心平气和、理解他人、不争不抢的状态。

4.1.2　行车路线设计

4.1.2.1　城市行车，设计行车路线应以行驶时间及距离最优为原则，尽量错开车流高峰时段，避开繁华街道、学校、医院、平交路口等交通拥堵路段。

4.1.2.2　长途行车，设计行车路线应以选择公路等级高及距离短为原则，并有备用行车路线。

4.1.3　出车前检查

4.1.3.1　检查车身外表及部件的状况：无漏油、漏水、漏气等现象；灯光、刮水器、除霜器完好；轮胎无损坏、无夹杂物、气压正常；备胎、随车工具、危险警告标志齐全完好。

4.1.3.2　检查发动机风扇、空调压缩机、水泵、发电机等传动带，张紧力合适，无老化、龟裂、翻毛边等现象；检查发动机冷却液、润滑油液面高度符合规定范围；检查离合器、制动器、转向器等机构的液面高度符合规定范围。

4.1.3.3　清除车厢内不必要的物品。

4.1.3.4　清洁车窗玻璃、车内外后视镜。

4.1.3.5　检查转向机构、离合器踏板、制动踏板，自由行程应正常。

4.1.3.6　检查驻车制动器操纵机构，工作应正常。

4.1.3.7　起动发动机后，仪表板无故障报警信号，车辆无漏油、漏水、漏气现象。

4.2　驾驶操作

4.2.1　发动机起动

4.2.1.1　配置手动变速器、汽油发动机的车辆，发动机起动时，将变速器操纵杆置于空挡位置，踩下离合器踏板，打开点火开关至起动位置，发动机顺利起动后立即松开，点火开关在起动位置的时间不应超过5s，起动过程中不应踩加速踏板。如果一次起动未能成功，应间隔10s（柴油发动机15s）后再次起动；两次起动不成功时，应进行检查，排除故障。

4.2.1.2　配置自动变速器、汽油发动机的车辆，发动机起动时，自动变速器挡位置于“P”挡或“N”挡位置，踩下制动踏板，其余操作方法同4.2.1.1。

4.2.1.3　柴油发动机常温及热起动时，操作方法同4.2.1.1或4.2.1.2；冷起动时，应首先开启发动机预热系统，在充分预热后再按4.2.1.1或4.2.1.2进行起动操作。对于国III以上柴油发动机，应打开点火开关，经5s～10s的系统自检后，再行起动。

4.2.2　车辆预热

4.2.2.1　发动机预热

4.2.2.1.1　非增压发动机起动后，保持发动机怠速运转1min（增压发动机怠速运转时间适当延长）。

4.2.2.1.2　在冬季温度较低时，保持发动机怠速运转至发动机冷却液温度达到40℃左右。

4.2.2.2　底盘预热

在发动机预热、汽车起步后，先以较低挡位、20km/h～40km/h速度行驶1km～2km后，再以正常速度行驶。在冬季温度较低时，低速行驶的距离应适当延长至3km～4km。

气压制动的汽车应在储气罐内的气压达到规定值（见汽车用户手册）后，再按4.2.2.2操作。起步后，行驶20m左右制动，检查气压制动系统有无泄漏。

4.2.3　起步

4.2.3.1　手动变速器汽车平路起步步骤如下：

a）左脚完全踩下离合器踏板，将变速器操纵杆置于“1”挡（部分大型车辆轻载时，可置于“2”挡）；

b）松开驻车制动，左脚先稍快松抬离合器踏板，待离合器处于半联动位置时（传动机件稍有振抖、发动机声音略有变化），右脚轻踩加速踏板，同时左脚再缓抬离合器踏板，直至汽车平稳起步后，左脚移离离合器踏板。

4.2.3.2　手动变速器汽车上坡起步步骤如下：

a）左脚完全踩下离合器踏板，将变速器操纵杆置于“1”挡；

b）拉紧驻车制动，右脚轻踩加速踏板提高发动机转速（坡度越大，需提高的转速越高），这时松抬离合器踏板到半联动位置；

c）当听到发动机声音发生变化时缓缓放松驻车制动，同时逐渐踩下加速踏板和缓抬离合器踏板，直至汽车平稳起步后，左脚移离离合器踏板。

4.2.3.3　手动变速器汽车下坡起步步骤如下：

a) 左脚完全踩下离合器踏板，将变速器操作杆置于“1”挡（坡度较缓时，变速器操作杆可置于“2”挡）；

b) 右脚踩制动踏板，同时松开驻车制动；

c) 左脚缓抬离合器踏板，同时右脚踩制动踏板控制速度（坡度越大，踩制动踏板的力越大），直至汽车平稳起步后，左脚移离离合器踏板。

4.2.4　换挡变速

4.2.4.1　手动换挡以根据发动机运行的经济转速（一般汽油发动机转速为2000r/min ～2500r/min；柴油发动机转速为1200 r/min～1500r/min）选择挡位为原则，并遵循以下原则：

a）尽量选择高挡位，使发动机在经济转速区域内的较低转速下运转；

b）发动机的转速高于经济转速区域时，及时选择升挡；

c）发动机的转速低于经济转速区域时，迅速选择降挡。

4.2.4.2　手动换挡时，应动作迅速，减少空挡转速损失，并遵循以下原则：

a) 汽车换挡变速踩下离合器踏板时，应及时抬起加速踏板；当抬起离合器踏板，离合器尚未完全接合时，不应急踩、猛踩加速踏板。

b) 升挡时，应自低挡位逐级换入高挡位，做到及时、准确。

c) 降挡时，应自高挡位换入预期行驶速度的、且能保持发动机转速在经济区域内较低转速下运转的低挡，做到及时、准确。

4.2.5　加速

4.2.5.1　加速踏板的位置遵循以下原则：

a) 汽车在平路行驶过程中，踩下加速踏板的最大限度应不超过加速踏板最大行程的3/4。

b) 汽车在上坡道路行驶过程中加速，如果已踩下加速踏板最大行程的3/4而发动机转速不能相应增加，应迅速变换低一级挡位后重新加速行驶。

4.2.5.2　踩下加速踏板的速度，以发动机的声音增高较柔和、转速平稳增加为宜。加速踏板由初始位置踩至3/4行程位置的时间应控制在3s～4s左右。

4.2.5.3　以下路况不得加速，确保安全：交叉路口、学校、人行横道、公共汽车站、弯道及其他视线不清的交通路况。

4.2.6　减速

4.2.6.1　行车中，应利用汽车带挡滑行减速，不得空挡滑行。

4.2.6.2　遇以下情况时，驾驶人应抬起加速踏板，依靠发动机对汽车的阻滞力减速滑行，必要时用行车制动器制动增加减速强度：

a) 预见前方有障碍物、红灯需要减速时；

b) 通过弯道、桥梁、交叉路口和坑洼路面时；

c) 通过坡度小于5%且路面较宽的下坡道；

d) 下陡坡接近平路的坡尾路段；

e) 对向车道有来车，需要会车时；

f) 通过车流、行人较多的交通繁忙地区或路旁集市；

g) 在预定停车地点适当距离之前，采用减速准备停车。

4.2.6.3　汽车行驶在长而陡的下坡道时，抬起加速踏板，离合器保持接合状态，发动机不熄火，变速器操纵杆置于合适的挡位（坡度越大，挂挡位越低），并根据速度情况使用行车制动器间歇制动控制车速。安装有缓速器的车辆，应充分利用缓速器减速。

4.2.7　车速控制

4.2.7.1　汽车在正常行驶时，变速器应尽量置于最高挡位，保持在发动机经济转速区域内较低转速下等速行驶。

4.2.7.2　当汽车行驶阻力增大，以及交通繁杂，应根据行车速度及时换入合适挡位。

4.2.7.3　在预定速度下，应保持好该状态时的加速踏板位置，使汽车等速行驶，尽量避免加速踏板位置来回变化。

4.2.7.4　在普通公路上，跟车距离一般应大于汽车2s～3s内驶过的距离；在高速公路上，跟车距离一般应大于汽车4s内驶过的距离。

4.2.7.5　汽车行驶的速度不应超过道路通行的有关限速规定。

4.2.8　转向控制

4.2.8.1　操纵汽车转向时应平顺，提前50m～150m开启转向灯，避免突然变向或急转弯等。

4.2.8.2　在汽车行驶过程中，尽量保持直线行驶，避免频繁变更车道或来回转动转向盘。

4.2.8.3　变更车道时，应在确认与前后左右的汽车处在安全距离的情况下，提前开启转向灯，夜间应变换使用远、近光灯，然后平稳地转动转向盘以较大的行车轨迹缓加速驶向另一车道。

4.2.9　会车

在无中央隔离装置道路会车时，应预先选择会车地点，提前降低车速，注意礼让。

4.2.10　典型路段驾驶

4.2.10.1　上坡路段驾驶遵循以下原则：

a) 遇见坡路时，应提前预测坡度、坡长，判断需用的挡位及速度，在坡前500m处应轻微加速，在坡路时保持加速踏板位置，尽量靠汽车惯性冲到坡顶。

b) 重载上陡坡时，应提前换入低挡位，避免中途换挡。

c) 当发动机提供的动力不足时，应迅速降挡，保持发动机动力上坡，避免坡路途中停车或熄火。

4.2.10.2　隧道驾驶遵循以下原则：

a) 在距隧道入口100m左右处，应提前减速，开启前照灯、示廓灯，仔细观察前方情况。

b) 在隧道内行驶时，应保持合适的跟车距离和行驶速度。

c) 在隧道出口前，应握稳转向盘，避免隧道出口处的横向风引起汽车偏离行驶路线。

d) 驶入和驶出隧道时，在明、暗适应过程中不应加速行驶。

4.2.10.3　城市拥挤路段驾驶遵循以下原则：

a) 在拥挤路段，汽车处于频繁的起步—停车的循环行驶状态，起步时应缓踩加速踏板，起步后尽员可能利用汽车惯性滑行行驶，避免起步后猛踩加速踏板再制动停车的驾驶方式。

b) 在汽车安全行驶的前提下，应减少完全停车，尽量使汽车保持一定的运动惯性。

4.2.10.4　高速公路驾驶遵循以下原则：

a) 在高速公路上尽可能保持经济车速等速行驶。

b) 在接近高速公路收费站或出口处，应提前抬起加速踏板，充分利用带挡滑行减速。

4.2.10.5　乡村道路驾驶遵循以下原则：

在泥泞道路行驶时，应选用低挡位，尽量保持车辆低速直线行驶，转向不可过急、过猛。

4.2.11　行车温度控制

4.2.11.1　发动机冷却液温度低于40℃时，不应使发动机大负荷高速运转或使汽车高速行驶，温度达到40℃以上时开始正常行驶。

4.2.11.2　应使发动机冷却液温度保持在80℃～95℃。长时间上坡或高速行驶等行驶状态下发动机冷却液温度报警时，应停车怠速或小负荷、低速行驶，使发动机冷却液温度慢慢降到正常区域。

4.2.12　发动机熄火

4.2.12.1　当汽车停止行驶后，应尽量减少发动机怠速空转，及时使发动机熄火。

4.2.12.2　非增压发动机汽车在路口停车等待通过的过程中，应根据交通信号灯计时器判断停车时间，停车时间超过60s的，应将发动机熄火。

4.2.12.3　非增压发动机汽车在上下乘客、装卸货物等需要停车超过60s时，应将发动机熄火。

4.2.12.4　非增压发动机汽车经过高速或爬长坡行驶后发动机冷却液温度很高时，应怠速运转30s以上后熄火。

4.2.12.5　增压发动机汽车在高速行车后不应立即熄火，应保持发动机怠速运转3min以上，再熄火。

4.2.13　行车中检查

4.2.13.1　在行驶过程中应经常注意查看车上各种仪表，查听发动机及底盘声音，如发觉操纵困难、车身跳动或颤抖、机件有异响或有异常气味、冷却液温度异常时，应立即停车检查并进行必要的调整和修理。

4.2.13.2　行驶中发动机动力突然下降，应立即停车检查冷却液或润滑油量（冷却液温度高时不能打开水箱盖）。

4.2.13.3　行驶中转向盘的操纵变得沉重并偏向一侧，应立即停车检查轮胎气压。

4.2.13.4　检查冷却液和润滑油量，应无漏水、漏油，气压制动应无漏气现象。

4.2.13.5　检查车轮制动器，应无拖滞、发热现象，驻车制动器作用可靠。

4.2.13.6　检查转向、制动装置和传动轴、轮胎、悬架等各连接部位，应牢固可靠。

4.2.14　停车

4.2.14.1　手动换挡汽车短时间停车时，将变速器操纵杆置于空挡，右脚踩住制动踏板；停车时间过长时，应将发动机熄火，将变速器操纵杆置于“1”挡（下坡路段停车时，应将变速器操纵杆置入“R”挡），并拉紧驻车制动。

4.2.14.2　准确判断停车位置，应做到一次停车到位，减少停车时的移车次数。

4.2.14.3　避免在上坡、积水、结冰或松软的路段上停车。

4.2.14.4　冬季中途停车时，应尽量避免汽车发动机迎风停放。

4.2.15　收车后检查

4.2.15.1　检查汽车，应无漏油、漏液、漏气现象，视需要补充燃油、润滑油和冷却液。

4.2.15.2　检查轮胎，气压应符合要求，胎间及表面无杂物及损伤。

4.2.15.3　检查风扇等的传动带，应完好且松紧度合适。

4.2.15.4　检查轮胎螺母和半轴螺母，应无松动。

4.2.15.5　打扫车厢和驾驶室，清洗底盘和清洁整车外表，同时查看各部位，应无破损。

4.2.15.6　汽车每行驶1000km时，应清除空气滤清器的灰尘。

4.2.15.7　高温天气下，应将车辆停放在阴凉处或车库内，或者在车窗上放置遮阴、热反射装置，防止阳光的直射升温。在寒冷天气，汽车长时间停驶时，为防止轮胎被冻住影响正常起步，必须在轮胎下面垫木板或砂子等物。

4.3　汽车燃润料、轮胎的使用及日常维护

4.3.1　车辆运行材料的合理选用

4.3.1.1　燃油

a) 油箱液面不应过低，燃油加注不应过多。当使用到油表显示还剩下不到1/4 的燃油时加油，每次加油至油表刻度的2/3～4/5 为宜。

b) 应参考车辆用户手册选择燃油的牌号，柴油车一般以最低使用温度略高于柴油的冷凝点4℃～

6℃为宜。

4.3.1.2　润滑油

a) 按车辆用户手册上的要求及时添加、更换润滑油。

b) 冬季宜使用低黏度的润滑油，夏季宜选用黏度稍高的润滑油，条件许可时宜选用多级润滑油。应根据季节变换，及时更换润滑油。

4.3.2　合理使用轮胎

4.3.2.1　宜选用子午线轮胎，轮胎胎面不宜过宽。

4.3.2.2　应定期进行轮胎换位。

4.3.2.3　出现轮胎花纹磨损超标时，应及时更换轮胎。

4.3.2.4　轮胎更换或者车轮有振动感时，应进行轮胎动平衡检查。

4.3.2.5　定期检查并校正车轮定位参数。

4.3.3　定期维护车辆

4.3.3.1　根据行驶里程或使用时间，按GB/T 18344的要求对车辆实施定期维护。

4.3.3.2　应定期清除进气系统的积碳。

4.3.3.3　应保持排气系统良好的工作状态。

4.3.3.4　应检查并保持制动系统良好的工作状态。

5　客车驾驶节能附加操作规范

5.1　行车前检查

行车前，检查行李舱内行李，应摆放均匀。

5.2　起步前检查

起步前，检查乘客人数，避免二次起步。

5.3　空调使用

5.3.1　使用空调时应关闭车窗，空调制冷温度应设定在26℃。

5.3.2　发动机运行平稳后再开启空调。客车上客前10min左右开启空调，下客后应及时关闭空调。

5.3.3　汽车在烈日下停放导致车内温度较高时，应先打开车窗，保持低速行驶，待车内空气温度降低后，再关闭车窗，开启空调。

5.3.4　空调出风口不应堆放杂物或悬挂物，不应在怠速状态下长时间使用空调，避免设置制冷温度过低而风量过小。

5.3.5　空调冷凝器和蒸发器表面、回风窗滤网、出风口等应保持清洁。

6　货车驾驶节能附加操作规范

6.1　厢式货车或集装箱专用运输车辆应装配导流罩等节能装置。

6.2　应根据装载容量、行驶路线、道路条件等选择合适的车型。

6.3　应根据道路和桥梁的通行能力，选择适合的路线。

6.4　当车辆以低于70km/h的速度行驶时，可开窗通风或使用空调的通风功能；当车辆以高于70km/h的速度行驶时，应关闭车窗并开启空调，空调制冷温度应设定在26℃。

6.5　装载时应使货物载重量均匀地分布于载货平面，且沿车辆纵向中心线均衡顺装，较重的物件应放置于载货平面的中部。

6.6　货物装载不得超高、超宽。

6.7　货物捆绑、固定应牢固，覆盖应严实。在行驶途中应经常检查货物捆绑、固定、覆盖状况。




======================

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(1)：基础知识

发表于2015/2/21 23:45:20  2579人阅读

分类： android

讨论QQ群：304570451(仅接受各开发组成员，各论坛开发者，广告、推销者勿扰)

这一篇是这一系列文章的起始，就暂不进入正题，先啰嗦一下一些基本的常识和一些题外话吧，这些知识也挺重要的，建议急性子的读者也多了解一下。

声明：本系列文章并非百科全书，笔者也不指望靠这些文章就能把一个初学适配者指导成一个高手，所以请读者碰到问题时请多动手尝试。

一、目的

写这一系列文章的目的，是为了总结出一种通用的方法，一种门槛不高，且不需要很深的编程基础，适用于大众的编译适配方法；使用这种方法，可以为各种基于高通msm8960平台的手机，编译适配出msm-aosp。

二、Android版本

4.4即kitkat是目前比较稳定的版本，也被大部分android手机所支持，所以笔者本系列文章专门针对此版本。但有些经验、方法总是共通的，其它的版本的系统甚至cm的编译适配也可以部分地参考本系列文章。

三、Rom的分类

虽然aosp是原生系统，但相对于官方系统来说，也属于第三方系统的范畴。 
总之除了官方rom、基于官方优化(汉化)的rom以外，其它种类的rom都属于第三方rom。 
而第三方rom按照其产生的方式仍然可以再分类：编译，插桩，移植 
那么一共就有4个分类 
优化：指的是修改优化官方rom(包括汉化) 
编译：指的是从源代码编译出来的rom 
插桩：指的是用代码插桩的方法适配出来的rom，一般使用patchrom系统 
移植：指的是从相近配置机型的rom以及本机型的底包rom中获取资源，通过文件替换的方式，产生的rom

四、Rommer的分类

笔者暂且按照rom的分类把rommer也分为优化者、编译者、插桩者、移植者。 
但并没有严格的阵营或界限，毕竟一个rommer可能做同时编译、插桩、移植、优化。 
优化者就不多说了，一般接触android都是从优化系统（汉化、修改）开始，这本身就是基础，即使是适配高手，优化的手段也都必须掌握。 
由于miui、乐蛙、百度等这些插桩型或移植型rom在国内的流行，所以国内的插桩者、移植者众多，相反国外的插桩者却不多，这是由国内的android生态圈所决定的。 
而android open source(现在已经墙了），github(访问巨慢无比)，XDA(也是慢而且还广告满天飞)，这些优秀的开源站或开源社区都在国外，于是诞生了cm、aokp等众多第三方rom，也就催生了许多国外的编译者，相反的国内的编译适配者屈指可数，这也是由国外的大环境所决定的。

五、google-aosp与高通的msm-aosp，这二者的关系

笔者所了解的，都是从代码以及rom中了解进而总结出来的，并不是搜索或从书里得来的。如果说得不对也请见谅！ 
Google作为业界大佬同时也是android项目的主导者，它的aosp开源项目就是所有android的源头，即所有的andriod版本都是从google-aosp中分化演进而来，包括高通的msm-aosp。 
至于为何笔者把高通的aosp当做一个相对独立的aosp系统呢？因为高通的cpu架构以及显示芯片Adreno、多媒体部分与google的标准存在差异，所以google的aosp代码不能直接用在高通平台。 
于是高通就把google的aosp的代码同步回去，经过修改（硬件抽象层、系统框架、通讯层），形成自己的版本，也就是msm-aosp。那么反过来，大佬google却不会从高通这边同步代码回去来适应高通的平台，毕竟google要坚持自己的标准，三星、德仪、MTK、麒麟等平台还是遵循google的标准的(未经过求证，只是笔者的猜想)。

六、非caf内核与caf内核

高通的开源社区叫做Code Aurora Forum，缩写就是caf。 
高通平台cpu用的内核一般就叫caf内核。 
一般情况下除了nexus系列手机以外，都是caf内核。 
那么谨记，msm-aosp必须配合caf内核，而非caf内核则可用于google aosp。 
OK，那么聪明的读者应该会想到，CM等第三方rom的编译系统既可以适配出caf内核的系统也可以适用于非caf内核，到底有什么诀窍呢？ 
因为cm集成了google和高通两者的硬件抽象层代码。 
举个例子(msm8960平台)： 
cm的hardware/qcom/display对应于google-aosp的hardware/qcom/display 
cm的hardware/qcom/audio对应于google-aosp的hardware/qcom/display 
cm的hardware/qcom/media对应于google-aosp的hardware/qcom/display 
而 
cm的hardware/qcom/display-caf对应于msm-aosp的hardware/qcom/display 
cm的hardware/qcom/audio-caf对应于msm-aosp的hardware/qcom/display 
cm的hardware/qcom/media-caf对应于msm-aosp的hardware/qcom/display

七、代码的版本revision与tag

这里所说的版本，并不是能看到的版本，比如android4.4.2或kernel 3.4这之类的版本 
而是指代码的版本，读者必须逐渐适应这个说法。 
android是有许许多多个代码目录组成，这些目录都是一个个独立的项目，可能有多个不同的开发人员负责维护，而单个项目每次提交更新会形成一个版本。 
而这些项目处于不断更新的状态，可能多个项目积累了几百次几千次的更新，才会形成一个大版本的跃进。 
那么每次编译比如4.4.2时，可能同一个项目的代码版本并不一样，因为之前说了项目一直在更新，于是很有必要使用代码版本的概念，对于git来讲，就是revision，每一次通过测试的编译，都把每个项目的revision记下来，众多项目形成一个tag。典型且容易理解的来讲，就类似cm的snapshot，比如CM11-M4，CM11-M5这样的版本。 
但高通则更为复杂一些，高通的开源站把通过release测试的tag版本都公布在这里： 
https://www.codeaurora.org/xwiki/bin/QAEP/release 
各种平台独立，且有一定的命名规律。

为了让读者能更直观的理解，下面的例子就是某个版本的tag，打开后可以看到各项目的 revison： 
￼

再举一个例子：msm8974平台的release tag，笔者列出了每个tag对应的android版本代号，其中KOT49H代表4.4.2_r1，KVT49L代表4.4.2_r2，KTU84L代表4.4.3，KTU84P代表4.4.4

tag版本android版本LNX.LA.3.5.1-01710-8x74.0.xmlKOT49HLNX.LA.3.5.1-01710-8x74.0.xmlKOT49HLNX.LA.3.5.1-02010-8x74.0.xmlKVT49LLNX.LA.3.5.1-02410-8x74.0.xmlKVT49LLNX.LA.3.5.1-02710-8x74.0.xmlKVT49LLNX.LA.3.5.1-03010-8x74.0.xmlKVT49LLNX.LA.3.5.1-03310-8x74.0.xmlKVT49LLNX.LA.3.5.1-03910-8x74.0.xmlKVT49LLNX.LA.3.5.1-04210-8x74.0.xmlKVT49LLNX.LA.3.5.1-04510-8x74.0.xmlKVT49LLNX.LA.3.5.1-05110-8x74.0.xmlKVT49LLNX.LA.3.5.1-05210-8x74.0.xmlKVT49LLNX.LA.3.5.1-05510-8x74.0.xmlKVT49LLNX.LA.3.5.1-05710-8x74.0.xmlKVT49LLNX.LA.3.5.1-05910-8x74.0.xmlKVT49LLNX.LA.3.5.1-06110-8x74.0.xmlKTU84LLNX.LA.3.5.1-06210-8x74.0.xmlKTU84LLNX.LA.3.5.1-06310-8x74.0.xmlKTU84LLNX.LA.3.5.1-06510-8x74.0.xmlKTU84PLNX.LA.3.5.1-06810-8x74.0.xmlKTU84PLNX.LA.3.5.1-06910-8x74.0.xmlKTU84PLNX.LA.3.5.1-07010-8x74.0.xmlKTU84PLNX.LA.3.5.1-07410-8x74.0.xmlKTU84PLNX.LA.3.5.1-07510-8x74.0.xmlKTU84PLNX.LA.3.5.1-07710-8x74.0.xmlKTU84PLNX.LA.3.5.1-07910-8x74.0.xmlKTU84PLNX.LA.3.5.1-08610-8x74.0.xmlKTU84PLNX.LA.3.5.1-08810-8x74.0.xmlKTU84PLNX.LA.3.5.1-09010-8x74.0.xmlKTU84PLNX.LA.3.5.1-09110-8x74.0.xmlKTU84P

从上面的例子可以看出，并非每个tag都是一个跨越式的版本升级，有些升级只是修复bug等。所以许多代码版本是升级了，但实际上android版本并没有变化。

八、最后的重点

请务必看完并理解此段的含义。 
一般情况下，通过tag同步下来的系统代码版本以时间为联系是统一的，唯有内核代码除外，因为手机的内核代码由手机厂商单独发布。 
如果内核代码的版本与系统代码的版本不匹配，那么编译就会出错，甚至编译出来的系统无法使用。 
那么经过思考，我们可以得出如下结论： 
方法一：要么固定系统代码版本，寻找匹配的内核代码版本 
方法二：要么固定内核代码版本，寻找对应的系统代码版本

对于方法一，如果同步了最新的系统代码，然后把厂商提供的内核代码也升级到最新的版本，那么这样就可以配合最新的系统代码，编译适配出完整ROM了。 
但这个门槛太高，因为能看懂内核代码能编程，需要经过系统的学习，并非几篇文章就能教会，而本文所讨论的则是通用的，低门槛的方法。

所以剩下只有方法二：识别内核代码的版本，再找到对应匹配的系统代码的版本(可能不是最新的)，再来做编译适配。虽然这种方法限制很大，但确实是适合大众的方法。 
那么如果我们有了厂商的内核代码，那么该如何找到匹配的系统代码呢？这个问题由之后的文章来解答。

那么，如何升级内核以适配出高版本的系统？ 
升级内核确实有一定的方法(后面的文章会阐述笔者总结的思路)，但如前所述，方法能总结出来，但编程技能无法靠几篇文章就能教会。 
反过来讲，如果一个高手能看懂、修改、编写内核代码，那么适配系统当然得心应手，不会拘泥于用什么方法。就像武侠小说里讲的，内功高手无所谓用什么招式，只有初学者才需要学招式






CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(2)：开发环境及相关的使用技巧

发表于2015/2/22 0:11:04  1784人阅读

分类： android

因为面对的是新手，这篇文章可能讲得比较宽泛，包括了硬件的选用，系统的选用，是否该用虚拟机，如何配置linux，linux的一些使用技巧，调试环境的搭建，脚本、工具的制作等等。

一、硬件

因为系统和内核的源代码是以千万行乃至亿行代码来算，所以同一台计算机完整编译一次系统的时间，可比插桩要来得多得多，想提升编译的效率，即降低编译所花的时间，拥有一台高配置电脑必不可少。 
在ram即内存足够的前提下，cpu速度起决定性作用，硬盘速度也十分重要；编译速度取决于cpu线程数&cpu单线程性能&硬盘速度 
所以多线程高性能的cpu+ssd可以大幅降低编译所花的时间。 
我自己的例子： 
i3-2350M主频2.3G，内存10G，2核心4线程，linux安装于ssd，编译时使用5个线程，总共需要约4个小时才能完成编译 
i7-4770主频3.4G，内存16G，4核心8线程，linux安装于ssd，编译时使用9个线程，总共只需要约40分钟即可完成编译 
这可是节省了3/4的编译时间(虽然编译只是适配的一部分，编译后的调试也很花时间)，因为从零开始编译适配需要多次重复编译，所以往往要花1个月甚至更多的时间，那么高配置的计算机节省下来的编译时间就非常可观。 
假如进行了100次编译，那么高性能计算机就可以为你节省300小时，即12.5天 
有句话说得好，能用钱解决的事都不叫做事，如果有条件的话，当然I7+16GRAM+SSD是最理想的。 
达不到的话也没事，最多就是多花几倍时间罢了，只要有耐心和毅力，没什么搞不定的。

二、linux的选择与安装

linux开发环境的安装配置，这里就不多说了，blog里有其它好几篇文章专门介绍，选一个你喜欢的系统就行了，也不一定用最新的系统，老的系统稳定好用就行，当然笔者推荐Vm11.0+Mint17.1 XFCE/Mate这个组合(目前是最新的)。 
纯正的ubuntu笔者是不推荐的，众所周知，其默认桌面太反人类了。 
至于要不要用虚拟机，笔者有做过对比试验，linux都安装于ssd，真实机编译与虚拟机编译，差距不大。而虚拟机明显能让计算机的利用率更高，毕竟我们可以边编译边用windows来做些其它事情，而且windows下做后期的调试也十分适合，所以笔者推荐使用虚拟机。 
注意：Vmware请勾选CPU选项里的“虚拟化 Intel VT-x/EPT或 AMD-V/RVI”以提高虚拟机性能。

三、linux的一些使用技巧

1.让使用更方便

如果单纯只是用于编译，那么大可不必太过在乎安全权限等方面的问题，密码也可以尽量设置得简单，默认用户直接提升为root权限即可，用起来方便，不要给自己找麻烦。

2.VmwareTools一定要装，且要安装正确。

好处有2点，一是小文件可以直接复制粘贴，二是设置共享文件夹直接与windows沟通 
共享文件功能的使用方法这里简单介绍一下(前提是已经正确安装了VmwareTools)： 
在虚拟机设置的“选项”页面，“共享文件夹”项，启用并设置文件夹 
￼

然后在linux的/mnt/hgfs目录下就可以读写这些共享的文件夹 
￼

这样做有什么好处？ 
笔者的硬盘是由普通磁盘+SSD构成的，但SSD只有120G的空间，存放了linux的虚拟机文件后就没有空间了，所以实际上虚拟出来的linux磁盘空间只有108G(SSD得留一些空余安全空间)，而有了这个共享的功能，就相当于扩展了磁盘空间，一些无用的文件，可以通过tar、zip、7z等工具压缩一下存放在真实机windows的磁盘里。

3.如何在终端快捷地输入命令

笔者推荐的几款linux，在任意文件夹下都可以打开终端 
而输入命令，特别是一些长的文件夹名称时，怎么快捷地输入呢？ 
答案是tab键，linux有自动拼写的功能，会识别命令、文件、文件夹名称。 
举个例子，在源码目录下，要输入source build/envsetup.sh这个命令该怎么输入？ 
sou[按tab键]bu[按tab键]/e[按tab键] 
只要读者多试几次就能掌握诀窍了。 
注意：linux是大小写区分的。

4.如何查看剩余磁盘空间

df -h

5.如何存放文件，如何压缩解压文件

除了必须存放在用户目录的文件，笔者一般把文件存放在/opt/下，当然这个因人而异，读者建个新的文件夹保存也完全没有问题。 
这里举个例子，如何把存放于/opt/cm11-m12的文件夹压缩存放于共享目录下 
先在文件浏览器里打开/mnt/hgfs/AndroidOpenSource/CyanogenMod[这是笔者假设的目录] 
然后右键打开终端，请善用tab键 
7z a cm11-m12.7z /opt/cm11-m12 –mx=9 –v4096m 
这句命令的意思是，把/opt/cm11-m12压缩存放在当前目录，文件名为cm11-m12.7z，压缩率为9(最高)，每4G进行分卷

然后再举个例子，如何把共享目录里的压缩文件解压到/opt/ 
先在文件浏览器里打开/mnt/hgfs/AndroidOpenSource/CyanogenMod[这是笔者假设的目录] 
然后右键打开终端，请善用tab键 
7z x cm11-m12.7z –o/opt/

6.解释一下压缩命令的语法

7z压缩率最高，所以推荐使用7z格式 
7z压缩文件夹命令 
7z a name.7z /opt/xxx [-mx=9 -v2048m] 
方括号里的为可选项，mx代表压缩率0~9，v2048m表示每2G分卷，如果不输入就是默认压缩率且不分卷

7z解压文件命令 
7z x name.7z -o/opt/ 
解压文件到/opt/目录，-o后面没有空格

Zip压缩文件夹 
zip -r -9 –y name.zip /opt/xxx 
-r代表目录，-9代表压缩率，-y代表保存符号链接

Zip解压文件 
unzip -d /opt/ name.zip 
解压文件到/opt/目录，-d后面有空格

tar压缩文件 
tar zcvf name.tar.gz /opt/xxx 
把/opt/xxx压缩成.tar.gz格式

tar解压缩 
tar zxvf name.tar.gz –C /opt/ 
解压文件到/opt/目录，-C后面有空格

7.查找文件命令

例如在当前目录下查找文件名包含abc的文件 
find . –type f –name "*abc" 
-type f限定了只找文件，如果不输入这个选项则会查找文件与文件夹 
举几个实用的例子 
当repo同步代码中断的时候，会留下一些tmp垃圾文件，且不会自动清除，那么用find命令+xargs就可以方便的删除掉 
先查找一下这些文件 
find . –name "tmp_*"

再用如下命令删除 
find . –name "tmp_*" | xargs rm –rf

当同步完代码checkout出来后，读者可能会把代码移动保存到一个新的文件夹里，但每个目录里都有.git文件，如何把这些文件删掉呢？ 
先查找一下这些文件 
find -name '.git*'

再用如下命令删除 
find -name '.git*' |xargs rm –rf

注意：不要在含有.repo的文件夹里执行这个命令，会把同步好的.repo删掉 
笔者是把同步好的代码移到另一个空文件夹，然后在这个新的文件夹里执行这个命令的

8.查找关键字命令

有时我们会需要在一大堆文件里找含有关键字的语句，命令如下： 
grep –r "关键字"

四、调试环境的搭建

1.android开发工具(ADT Bundle)下载

谷歌把它叫做ADT Bundle，但实际上就是eclipse+adt插件而已，本质上还是eclipse。 
虽然我们不做开发，但eclipse的实时查看log功能还是很好用的，这点在我们后续调试rom时可以用到。 
google的android开发站点被墙了，这是国内的镜像站 
http://tools.android-studio.org/ 
读者得花时间研究一下这个站的说明，并且熟悉一下开发工具 
开发工具分为eclipse和android-studio，笔者觉得eclipse用来看log比较好，所以推荐这个 
下载ADT Bundle ADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境

请根据自己的windows操作系统版本来选择32位或64位下载地址。 
记得选择windows版的即可。

然后下载JDK(eclipse需要用) 
32位jdk-6u45-windows-i586.exe 
http://download.csdn.net/detail/benjaminwan/8452547

64位jdk-6u45-windows-x64.exe 
http://download.csdn.net/detail/benjaminwan/8452549

2.关于eclipse的汉化(对于英文达人，此步骤不是必须)

方法一：这个方法最方便，但网络不好的话要等很久 
打开eclipse 
Help->Install New Software 
Work with填入http://download.eclipse.org/technology/babel/update-site/R0.12.1/juno 
回车并等Pending，如果半小时列表还没出来，读者还是考虑其它方法吧 
如果列表出来了，选中所有中文语言包，然后接着安装即可

方法二：直接下载完整zip汉化包 
http://eclipse.org/downloads/download.php?file=/technology/babel/update-site/R0.12.1/babel-R0.12.1-juno.zip 
找国内的下载地址 
下载完成后，解压任意目录 
Help->Install New Software 
Work with填入上面解压的目录 
等Pending出来 
过滤器填Chinese (Simplified)，过滤的过程中会比较卡，等待 
每项展开全部选中xxxx in Chinese (Simplified) 
Next，非常慢，可能要等10分钟 
I accept -> Finish 
安装过程也很慢噢 
如果嫌慢，直接覆盖方法三汉化好的版本得了

方法三：直接下载笔者汉化好的eclipse覆盖 
链接: http://pan.baidu.com/s/1mgsra8C 密码: w3bq 
eclipse-chs_x64-20140702.rar 
笔者只能提供64位版本的，读者如果是32位系统那就只能自己想办法了。

3.如何使用eclipse来调试

打开eclipse后，选中“窗口”->“打开透视图”->DDMS 
当连上手机并开启调试后，就会是如下这个样子 
￼
左上角是进程列表，连上数据线且开了调试之后会显示 
右边是线程，右边的窗口暂时用不到，只有app开发才会用到 
重点是底下的窗口 
比如要看所有error，那么就把级别选到error

￼

有一个搜索过滤栏，比如缺lib的时候，就输入lib，那么含有lib关键字行的就会被快速过滤出来，那么缺哪个lib就能一下找到。 
￼

左侧还有一个预设的筛选条件 
可以预设几个关键字，比如选择wifi时，就会过滤出wifi相关的信息 
￼

如何截图？ 
￼
Devices窗口工具条里有个相机图标，先选中需要截图的设备，再点相机按钮即可

4.adb命令脚本

为了调试方便，免得老是手动输入adb命令，把相关的adb命令做成脚本。 
可以下载笔者制作好的：http://download.csdn.net/detail/benjaminwan/8452161 
或者读者自己制作，下面讲制作方法 
新建一个文件夹，名字就叫ADB_Command_Tools 
然后把上一步下载的开发工具的sdk\platform-tools\下的 
adb.exe 
AdbWinApi.dll 
AdbWinUsbApi.dll 
这3个文件复制到ADB_Command_Tools文件夹

然后把如下内容存为Tools.bat文件，也放在ADB_Command_Tools文件夹

@echo off title 启动临时Recovery / boot to temporarily Recovery color 0B :start cls echo. Adb Command Tools Made by benjaminwan 2015.2.10 echo. ┏━━━━━━━━━━━━━━━━━━━━━━┓ echo ┃1.重启系统 (adb reboot) ┃ echo. ┣━━━━━━━━━━━━━━━━━━━━━━┫ echo ┃2.重启至Recovery模式(adb reboot recovery) ┃ echo. ┣━━━━━━━━━━━━━━━━━━━━━━┫ echo ┃3.重启至Fastboot模式(adb reboot bootloader) ┃ echo. ┣━━━━━━━━━━━━━━━━━━━━━━┫ echo ┃4.以root用户调试 (adb root) debug编译才行┃ echo. ┣━━━━━━━━━━━━━━━━━━━━━━┫ echo ┃5.重新挂载分区读写 (adb remount) ┃ echo. ┗━━━━━━━━━━━━━━━━━━━━━━┛ set /p KEY= [您的选择是:] if %KEY% == 1 goto NO1 if %KEY% == 2 goto NO2 if %KEY% == 3 goto NO3 if %KEY% == 4 goto NO4 if %KEY% == 5 goto NO5 goto error :NO1 echo. echo. 正在重启 echo. adb reboot goto start :NO2 echo. echo. 重启至Recovery模式 echo. adb reboot recovery goto start :NO3 echo. echo. 正在重启至Fastboot模式 echo. adb reboot bootloader goto start :NO4 echo. echo. 以root用户调试 adb root pause goto start :NO5 echo. echo. 重新挂载分区读写 adb remount pause goto start :error echo. Input error,please retry! echo. 您输入有误，请重新输入! echo. 您輸入有誤，請重試! pause goto start123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566

运行后，就是如下界面 
￼

然后说明一下，adb root这个命令是编译android时选择debug编译才能使用的，用了这个命令相当于取得了root权限，无需su命令。 
在今后调试aosp时，我们可能还未集成supersu等root工具，就需要这个命令取得root权限，此点在后续的文章里就不再细讲。

5.lib传送工具

笔者制作的工具包：http://download.csdn.net/detail/benjaminwan/8452141 
按照工具包里的说明安装即可 
￼

这个工具主要用来把lib传送到手机的对应位置，在后续的调试缺lib时十分有用，读者也可以参考提供的资源自己制作一个类似的工具。

总结来讲，工具不是必须，但适配的毅力则是必须，没有工具和环境也照样能做适配，只不过艰苦一些 
不过当笔者刷机100次后才醒悟，没有工具和环境真的是折腾自己。

1 0




CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(3)：寻找正确的代码版本

发表于2015/2/22 0:27:55  2717人阅读

分类： android

实际上此篇才是适配旅程真正的起点，读者务必掌握此篇内容才能真正开始编译适配。

在第一篇基础知识里讲过，内核代码由厂商发布，系统代码网上可以同步得到。 
内核与系统这2者的代码版本必须相互配合，这就意味着只有2条路： 
方法一：内核版本不变，找对应的系统代码(可能不是最新的代码)； 
方法二：系统代码固定(取最新的)，手工升级厂商提供的内核代码以配合最新的系统代码(当然没有降级这种做法)。

基础知识里也讲过，如果能看懂、修改、编写内核代码，适配系统当然得心应手，也就无需遵循什么条条框框，可惜这个方法并不适用于大众。

本系列文章面向的是一般文化水平，可能无编程基础的普通人，所以只能选方法一，当然掌握了方法一，有一定基础的读者也可以更进一步，尝试升级内核的方法，此点会在此篇文章里稍微介绍。

注意：虽然本文面向一般大众，但笔者认为至少有代码插桩经验的rommer来尝试比较合适

一、找官方内核版本的技巧

MS8960平台找版本十分容易，但以下介绍的方法估计不能用于msm8974平台

方法1：log法

用官方系统即可，取从开机到进系统这段时间的log，并搜索“AU_LINUX_ANDROID”关键字

方法2：grep法

把官方rom解压到linux里，然后在system文件夹下打开终端，用命令搜索 
grep –r “AU_LINUX_ANDROID” 
如果是4.4系统，至少会搜索到2个lib，用ultraedit打开，然后仍然搜索关键字就能找到

二、依据内核版本找到对应的release tag

注意事项：高通的开源站点在国内(北京)设有分站，所以访问速度理应很快；但同一个域名在国外也有站点，如果你使用了google的dns服务器，那么会解析成国外地址，造成访问速度很慢；这里有一个方法来判断，先在linux下ping codeaurora.org，并记下ip地址，然后到这里查询此ip http://ip.chinaz.com/，如果显示地址为美国，那么读者需要修改真实电脑的网卡ip设置，不要使用google的dns解析服务器。

1.举例

假设我们上一步找到的版本为： 
AU_LINUX_ANDROID_KK_2.7_RB1.04.04.02.007.050

2.同步manifests

在linux下，创建一个文件夹例如/opt/msm-aosp
在这个新建的文件夹中打开终端，并输入命令 
repo init -u git://codeaurora.org/platform/manifest.git -b release –repo-url=git://codeaurora.org/tools/repo.git –repo-branch=caf-stable 
20M的宽带的话，同步速度至少有1MB/s 
如果是首次使用git，则需要用命令设置一下用户名和邮箱，按照提示设置即可，下为例子 
git config –global user.name “benjaminwan” 
git config –global user.email “benjaminwan@home.com” 
同步完成后，启用”查看”->”显示隐藏文件” 
可以看到当前目录下有个.repo文件夹，进入会发现有个manifests文件夹，这个就是存放tag的地方了

3.搜索xml

在manifests文件夹下用文件浏览器的搜索功能，关键字就填入之前找到的内核版本 
或用命令find . -name "*AU_LINUX_ANDROID_KK_2.7_RB1.04.04.02.007.050*" 
可以找到caf_AU_LINUX_ANDROID_KK_2.7_RB1.04.04.02.007.050.xml这个文件，如果仅仅是找到正确的版本，其实到这里就已经结束了，但为了更深入地解释，就有了接下来的内容。 
现在我们打开它，解释一下这个文件的结构 
project代表某个项目，path代表这个项目同步后最终放在哪个目录，revision就是版本了，upstream是分支号 
￼
接下来找到kernel/msm这项，并记下它的revision：e1926e0c614b3e352b128dd0c7d3c7a914cfbe28 
然后以此revision来搜索 
grep -r “e1926e0c614b3e352b128dd0c7d3c7a914cfbe28” 
接下来可以找到以LNX开头的3项： 
LNX.LA.2.7.4-00500-8960.0.xml 
LNX.LA.2.7-05010-8064.0.xml 
LNX.LA.2.7-05010-8960.0.xml 
通过观察文件名，可以排除第一项，因为2.7.4这个分支号不对，前面我们看到的分支号是2.7 
剩下的2项其实内容一样，读者自己用文件对比工具打开对比一下便知。 
那么最终正确的tag就是LNX.LA.2.7-05010-8960.0

4.高通的release页面

https://www.codeaurora.org/xwiki/bin/QAEP/release 
搜索一下是否存在这个tag，以验证信息对不对 
￼
至此就完成了找版本的步骤

三、同步系统代码

repo init -u git://codeaurora.org/platform/manifest.git -b release -m LNX.LA.2.7-05010-8960.0.xml --repo-url=git://codeaurora.org/tools/repo.git --repo-branch=caf-stable repo sync123

checkout出来后的代码就是这个版本的官方内核所需要的对应版本的msm-aosp系统代码了

同步完成后，.repo这个隐藏文件夹的内容将会达到20G多的大小，而且在后续的适配中已经不再需要这个文件夹了。这个是全仓库代码，当你下次还想同步的时候，可以仍然用这个.repo同步出其它任意tag版本的代码。

既然如此，读者可以把这个.repo文件夹用压缩工具压缩保存，压缩率就选无压缩即可，以节省linux的磁盘空间。

而同步出来的代码，建议读者建立一个新的文件夹保存，文件夹的命名就以版本号为名，以免以后时间久了忘记自己同步的代码版本，例如在本例里笔者就以msm-aosp_LNX.LA.2.7-05010-8960.0这个名字来命名文件夹

然后即可删除每个文件夹下的.git文件，这个文件是git用来管理的，编译无需这些文件，读者可参考第2篇文章用命令find -name ‘.git*’ |xargs rm –rf来删除这些多余的文件

最后，建议读者再把现在这个代码文件夹再用压缩工具压缩备份一次，因为后面还要更改多处代码，备份以免万一。

请不要觉得麻烦，因为咱们后面做的适配比这麻烦百倍，如果读者在这里已经麻烦得受不了，那么就请您到这放弃吧。

四、延伸知识

1.相近的版本

通过上面的范例可以知道，高通的release tag有一定的命名规范 
LNX.LA.2.7-xxxxx-8960.0.xml 
中间5个xxxxx为数字 
那么我们试着查找一下类似的文件 
find . -name "LNX.LA.2.7-*-8960.0.xml" 
./LNX.LA.2.7-02710-8960.0.xml 
./LNX.LA.2.7-01210-8960.0.xml 
./LNX.LA.2.7-03110-8960.0.xml 
./LNX.LA.2.7-02410-8960.0.xml 
./LNX.LA.2.7-05210-8960.0.xml 
./LNX.LA.2.7-02110-8960.0.xml 
./LNX.LA.2.7-04010-8960.0.xml 
./LNX.LA.2.7-03910-8960.0.xml 
./LNX.LA.2.7-01910-8960.0.xml 
./LNX.LA.2.7-06310-8960.0.xml 
./LNX.LA.2.7-04310-8960.0.xml 
./LNX.LA.2.7-02810-8960.0.xml 
./LNX.LA.2.7-02910-8960.0.xml 
./LNX.LA.2.7-04410-8960.0.xml 
./LNX.LA.2.7-04710-8960.0.xml 
./LNX.LA.2.7-01110-8960.0.xml 
./LNX.LA.2.7-05010-8960.0.xml 
如何知道这些tag具体是哪个android版本呢？ 
通过review页面来看，例如 
https://www.codeaurora.org/cgit/quic/la/platform/build/tag/?id=LNX.LA.2.7-06310-8960.0 
id=这边可随意更改为tag名称 
然后按download，把这个revision的代码下载回去 
打开core/build_id.mk就可以看到export BUILD_ID= KTU84L 
打开core/version_defaults.mk就可以看到PLATFORM_VERSION := 4.4.3

2.升级内核代码的原理

前提当然是准确的找到内核当前的版本了。 
官方内核肯定是基于某个高通内核版本进行修改的。 
如果没安装git图形用户工具，请先安装一下 
apt-get install gitk或者apt-get install qgit

假设我们当前的版本是05010，并且已知为android 4.4.2_r1 KOT49H 
现在我们知道后面还有06310，并且版本为android 4.4.3 KTU84L

想要把内核升级到适配android 4.4.3 KTU84L版本该怎么做呢？ 
首先把高通的内核代码仓库同步下来 
新建一个文件夹例如/opt/msm-kernel 
git clone git://codeaurora.org/quic/la/kernel/msm 
等同步完成，进入刚同步好的文件夹，打开终端 
这里介绍一个新的命令gitk tagA..tagB或qgit tagA..tagB 
解释一下这个命令的意思，以图形方式显示从tagA到tagB之间经历的变化，示范如下 
gitk LNX.LA.2.7-05010-8960.0..LNX.LA.2.7-06310-8960.0 
或 
qgit LNX.LA.2.7-05010-8960.0..LNX.LA.2.7-06310-8960.0 
￼
读者就可以看到从05010到06310，高通标准内核经历了哪些变化。 
那么以此为参考，去升级官方内核代码就行了。 
至于是否有比手工升级更为方便的方法，当然方法各种各样。 
git rebase、git merge、git cherry-pick等本文重点不在这里也就不再提了。

2 0





CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(4)：验证代码并编写自己的device

发表于2015/2/22 1:08:02  2900人阅读

分类： android

前面花了那么多篇幅做准备，直到此篇才开始真正开始讲适配，读者一定很激动，但先不要高兴得太早，笔者必须先提出一个声明，虽然此系列文章不要求读者有编程基础，但理所当然的不具备者在适配时难度更大(只能靠经验和资料)；而具备编程基础的读者也不要高兴得太早，其实很多时候适配并非靠技术，而是靠不懈的毅力。

注意：初次适配者，如果仅靠本系列文章的解惑，依照个人能力、悟性、业余时间的差别，没有2~6个月或更长的时间，是无法做完整个适配过程的。

一、验证编译环境是否正确

首先以高通的内核以及高通提供的范例device来做一次完整编译，以验证开发环境是否OK 
在msm-aosp_LNX.LA.2.7-05010-8960.0目录右键打开终端

source build/envsetup.sh lunch 输入msm8960所在行的编号，比如8. msm8960-userdebug，那么就输入8并回车 make otapackage –j51234

这里-j5代表编译使用5个线程，如果是i7则可以使用9个线程，具体依cpu自身线程数读者自行确定 
如果没有错误，最后会生成msm8960-ota-eng.root.zip类似这样刷机包

二、验证手机内核版本与msm-aosp系统版本是否匹配

msm-aosp编译系统在进行编译时会引用内核的一些变量，如果版本对不上，编译会出错。 
想必读者早早就下载好了手机的官方提供的内核源代码，这步就可以用上它了。 
本文及之后的适配教程就以泛泰手机Vega_IM-A870L为例子，所以这个手机的内核代码就必须去泛泰官方的开源站点去下载。 
高通的kernel与手机的kernel是不一样的，高通的kernel只是用于高通的骁龙开发板(笔者猜测)，而一般手机kernel会在高通kernel的基础上添加许多芯片驱动(当然各家手机公司用的不一样，这个并没有什么统一的标准)

1.放置手机官方内核源代码

首先把aosp源代码目录的kernel文件夹删除。 
然后把官方提供的内核代码解压，按照之前的kernel目录结构放置 
必须注意的是，msm-aosp编译系统不提供像cm那样的多层目录结构以支持多机型多内核让你可在选device时选中对应的内核。aosp只有kernel这个目录，所以要是未来还要适配其它机型，你仍然得替换这个目录。当然如果读者未来有能力了，参照cm去更改编译系统以支持多个内核源代码就更好了。

2.内核配置文件

然后下一步就要找内核的配置文件名，一般官方内核代码解压后，可以在相关说明文档中或编译脚本中找到，泛泰a870的例子是msm8960_ef52l_tp20_perf_defconfig 
这个内核配置文件，可以在内核代码目录的arch/arm/configs里找到，读者不妨打开它，了解一下它的用处，笔者也顺便说说这个文件一个能自定义的地方：

CONFIG_LOCALVERSION="-perf"1

这个会显示在系统的关于里，内核版本这个栏位里 
许多cm内核会改成CONFIG_LOCALVERSION=”-CM” 
读者可以改为自己的id，但请勿尝试使用中文，笔者完全不推荐这么做。

cm的kernel config项是放在BoardConfig.mk里 
而msm-aosp是放在AndroidBoard.mk里，这是个不同点 
那么就打开AndroidBoard.mk修改msm8960_defconfig换成你的手机内核对应的配置名称，这里笔者的例子就改成msm8960_ef52l_tp20_perf_defconfig 
删除源码根目录的整个out目录 
然后按照之前介绍的命令，重新完整编译一次。 
如果没有错误，才可以继续进行下一个步骤。 
如果有问题，请重新回顾上一篇文章的内容，重新找对版本再继续。

三、修改高通自带的device

首先，笔者希望读者能首先熟悉device的编写方法，这个是做编译适配的基础技能，而且有必要从现在就开始练习。 
其次，不要指望参考cm之类的第三方rom的device，当你的机型不被cm支持时，不就傻眼了吗。

1.压缩device/qcom备份一下

2.device/qcom改名并处理多余文件

删除device/qcom下除了msm8960和common文件夹以外的文件夹 
然后把原device/qcom/msm8960改名为device/pantech/a870 
device/pantech/a870文件夹下删除所有.kl、.kcm、.conf、.accept、.deny、.rc、.sh、.ini、.dat、.bin、、sec_config、vold.fstab等文件，并在msm8960.mk里找到相应的copy语句，并删除之。 
删除media文件夹、radio文件夹、snd_soc_msm文件夹，同理在msm8960.mk里找到相应的copy语句，并删除之。 
最终剩下overlay文件夹、Android.mk、AndroidBoard.mk、AndroidProducts.mk、BoardConfig.mk、egl.cfg、fstab.qcom、msm8960.mk、recovery.fstab、system.prop

3.处理device/pantech/common文件夹

删除device文件夹、dtbtool文件夹、init文件夹、media文件夹、product文件夹、rootdir文件夹、recovery文件夹，并在common.mk里找到相应的copy语句，并删除之。

4.把common合并到a870文件夹里

合并后common文件夹删除，如果碰到同名文件，就把文件内容进行合并

5.再回到device/pantech/a870文件夹

新建bluetooth文件夹，并把bdroid_buildcfg.h移动到新建的文件夹里 
对应的BoardConfig.mk里的语句也必须更改 
BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR := device/pantech/a870/bluetooth 
msm8960.mk文件改名为a870.mk，对应的AndroidProducts.mk里也必须打开来修改 
然后打开a870.mk，修改 
PRODUCT_NAME := a870 
PRODUCT_DEVICE := a870 
common.mk改名为device.mk，并打开a870.mk修改对应的路径名称 
device.mk中删除所有非msm8960的行，PRODUCT_BRAND := qcom改为读者手机生产商，本例里改为pantech 
grep –r “recovery”找一找有没有哪个配置文件有recovery相关的编译配置 
删除所有含有recovery的行（注意保留第2步里提到的recovery.fstab）

6.修改vendorsetup.sh

仅保留如下语句即可 
add_lunch_combo a870-userdebug

7.删除vendor/qcom

删除vendor/qcom/opensource/kernel-tests 
并在device.mk中删除对应的#KERNEL_TESTS语句 
把vendor/qcom压缩备份，然后把vendor/qcom删除以避免在后续的编译中出错

8.修改过程如果有些文件不知道在哪，请善用grep –r “关键字”来查找文件内容

9.边编译边修正错误

有些错误在编译时才容易找到。 
source build/envsetup.sh 
lunch 
输入a870所对应的数字并回车 
make otapackage –j5

10.编译recovery错误

因为我们把相关的配置项删除了，而编译系统又必须编译，所以我们这里要更改编译系统去掉recovery的编译 
打开build/tools/releasetools/ota_from_target_files 
注释如下语句

line454 #script.UnpackPackageDir("recovery", "/system") line462 #recovery_img = common.GetBootableImage("recovery.img", "recovery.img", # OPTIONS.input_tmp, "RECOVERY") #MakeRecoveryPatch(OPTIONS.input_tmp, output_zip, recovery_img, boot_img) line617 #source_recovery = common.GetBootableImage( # "/tmp/recovery.img", "recovery.img", OPTIONS.source_tmp, "RECOVERY", # OPTIONS.source_info_dict) #target_recovery = common.GetBootableImage( # "/tmp/recovery.img", "recovery.img", OPTIONS.target_tmp, "RECOVERY") line765 #if updating_recovery: # script.Print("Unpacking new recovery...") # script.UnpackPackageDir("recovery", "/system")12345678910111213141516

对于初次适配者来说，做完这步可能都得花上1~2天的时间，许多配置项读者不理解但无需担心，在之后漫长的适配历程中，读者就会自己慢慢体会并慢慢懂得。

四、如何节省编译时间

因为反复编译确实很花时间，所以这里专门用一小节的内容来讲如何节省编译时间

1.如何重新编译以节省编译时间

虽然我们反复修改编译，但不变的有2个 
一个是out/host，这个目录是用于存放编译过程中linux本身需要的一些工具 
另一个是out/target/product/a870/obj/KERNEL_OBJ，这个目录是存放内核临时文件的，因为内核我们不改动，所以这个目录每次编译也就不会变化 
于是我们每次删除重新编译就只要保留上面2个目录，其它文件都删掉即可，这样可节省约1/4的编译时间

2.建一个编译脚本

免得每次编译时敲一长串语句

#!/bin/bash CPU_JOB_NUM=$(grep processor /proc/cpuinfo | awk '{field=$NF};END{print field+1}') function build_target() { echo '<<<<<<开始编译>>>>>>' START_TIME=`date +%s` source ./build/envsetup.sh lunch a870-userdebug make otapackage -j$CPU_JOB_NUM END_TIME=`date +%s` let "ELAPSED_TIME=$END_TIME-$START_TIME" echo "Total compile time is $ELAPSED_TIME seconds" echo "Total compile time is $ELAPSED_TIME seconds" > time.txt } build_target echo 编译结束 !!! exit 012345678910111213141516171819

把如上内容保存成a870.sh，保存在源代码根目录 
然后给执行权限 
chmod a+x a870.sh 
以后每次编译时只要执行./a870.sh就可以了 
而且编译完后，会生成一个time.txt文件，里面记录了编译过程一共多少秒，读者就可以知道编译一次花了多少时间。

五、改写device.mk

高通的范例是二段式的写法，举个例子：

#ANGLE ANGLE := libangle 在文件底部还有 PRODUCT_PACKAGES += $(ANGLE)1234

而通常的写法是

#ANGLE PRODUCT_PACKAGES += \ libangle123

打个通俗的比方，高通的语句加了个中间变量，就像这样

A=笨蛋 傻瓜=A12

但其实通常我们只要直接 笨蛋=傻瓜 这样就好了

改写完成后，把一些类似功能的项目集中在一起，比如音频相关的就放在一起 
续行符\要记得自己补上

PRODUCT_PACKAGES += \ audio_policy.msm8960 \ audio.primary.msm8960 \ audio.a2dp.default \ audio.usb.default \ audio.r_submix.default \ libaudio-resampler1234567

然后PRODUCT_LOCALES += hdpi mdpi这里 
依情况增加xxhdpi和xhdpi 
如果是720p就改为PRODUCT_LOCALES += xhdpi hdpi mdpi 
如果是1080p就改为PRODUCT_LOCALES += xxhdpi xhdpi hdpi mdpi

最后，把所有的:=改成+=，请一定改过来，否则后面有些语句会有问题

全部搞定后，编译一次看看有没有什么语法错误

六、修改BoardConfig.mk

先去掉一些无用的项目

TARGET_USE_HDMI_AS_PRIMARY := false ifeq ($(TARGET_USE_HDMI_AS_PRIMARY),true) TARGET_HAVE_HDMI_OUT := false else TARGET_HAVE_HDMI_OUT := true endif # TARGET_USE_HDMI_AS_PRIMARY TARGET_HAVE_HDMI_OUT := false TARGET_INIT_VENDOR_LIB := libinit_msm12345678

把 
-include vendor/qcom/proprietary/common/msm8960/BoardConfigVendor.mk 
改成 
-include vendor/pantech/a870/BoardConfigVendor.mk 
并把这个语句移动到文件底部

然后把这些项目按功能来分类，以便我们后续修改 
下面是笔者的分类，请读者参考如下标签来把语句分类

# CPU # Krait optimizations # Kernel # BootLoader # Platform # Graphics # Audio # Bluetooth # Wifi # File System # Camera # GPS # USB & Vold # Vibrator # Other123456789101112131415

以下举例

# CPU TARGET_GLOBAL_CFLAGS += -mfpu=neon -mfloat-abi=softfp TARGET_GLOBAL_CPPFLAGS += -mfpu=neon -mfloat-abi=softfp TARGET_CPU_ABI := armeabi-v7a TARGET_CPU_ABI2 := armeabi TARGET_ARCH := arm TARGET_ARCH_VARIANT := armv7-a-neon TARGET_CPU_VARIANT := krait TARGET_CPU_SMP := true ARCH_ARM_HAVE_TLS_REGISTER := true # Krait optimizations TARGET_USE_KRAIT_BIONIC_OPTIMIZATION := true TARGET_USE_KRAIT_PLD_SET := true TARGET_KRAIT_BIONIC_PLDOFFS := 10 TARGET_KRAIT_BIONIC_PLDTHRESH := 10 TARGET_KRAIT_BIONIC_BBTHRESH := 64 TARGET_KRAIT_BIONIC_PLDSIZE := 64 # Kernel BOARD_KERNEL_BASE := 0x80200000 BOARD_KERNEL_PAGESIZE := 2048 BOARD_RAMDISK_OFFSET := 0x02000000 BOARD_MKBOOTIMG_ARGS := --ramdisk_offset 0x02000000 BOARD_KERNEL_CMDLINE := console=ttyHSL0,115200,n8 androidboot.hardware=vu2sk user_debug=31 msm_rtb.filter=0x3F ehci-hcd.park=3 maxcpus=2 lpj=67741 # BootLoader TARGET_NO_BOOTLOADER := true TARGET_BOOTLOADER_NAME := msm8960 TARGET_BOOTLOADER_BOARD_NAME := MSM8960 # Platform TARGET_NO_RADIOIMAGE := true TARGET_BOARD_PLATFORM := msm8960 TARGET_USES_QCOM_BSP := true TARGET_ENABLE_QC_AV_ENHANCEMENTS := true TARGET_POWERHAL_VARIANT := qcom # Graphics TARGET_USES_ION := true TARGET_USES_OVERLAY := true BOARD_EGL_CFG := device/pantech/a870/egl.cfg # Audio BOARD_USES_GENERIC_AUDIO := true BOARD_USES_LEGACY_ALSA_AUDIO := true12345678910111213141516171819202122232425262728293031323334353637383940414243444546

等等，后面就不详细说了

七、修改boot参数

BoardConfig.mk里的# Kernel小节 
内核的基地址，偏移地址，以及传递参数

BOARD_KERNEL_BASE BOARD_RAMDISK_OFFSET BOARD_MKBOOTIMG_ARGS BOARD_KERNEL_CMDLINE1234

这些参数必须从读者的官方rom的boot.img里获取信息，请参考基础知识，后半部分关于修改的 
http://blog.csdn.net/benjaminwan/article/details/8952736 
注意文章最后一个图片里的3个红框 
读者编译出来的boot.img与官方的对比，3个红框的内容要完全一样才行 
另外介绍一个新的编译命令 
make bootimage –j5这个命令单独编译boot.img

八、修改ramdisk

在device/pantech/a870里新建一个ramdisk目录
把官方boot的ramdisk里的所有init.xx全部复制进去，并修改device.mk添加类似如下语句

PRODUCT_COPY_FILES += \ $(LOCAL_PATH)/ramdisk/init.pantech.usb.rc:root/init.pantech.usb.rc \ $(LOCAL_PATH)/ramdisk/init.pantech.usb.sh:root/init.pantech.usb.sh \ $(LOCAL_PATH)/ramdisk/init.qcom.rc:root/init.qcom.rc \ $(LOCAL_PATH)/ramdisk/init.qcom.sh:root/init.qcom.sh \ $(LOCAL_PATH)/ramdisk/init.qcom.syspart_fixup.sh:root/init.qcom.syspart_fixup.sh \ $(LOCAL_PATH)/ramdisk/init.rc:root/init.rc \ $(LOCAL_PATH)/ramdisk/init.target.rc:root/init.target.rc \ $(LOCAL_PATH)/ramdisk/init.class_main.sh:root/init.class_main.sh \ $(LOCAL_PATH)/ramdisk/init.qcom.class_core.sh:root/init.qcom.class_core.sh \ $(LOCAL_PATH)/ramdisk/init.qcom.early_boot.sh:root/init.qcom.early_boot.sh \ $(LOCAL_PATH)/ramdisk/ueventd.qcom.rc:root/ueventd.qcom.rc \ $(LOCAL_PATH)/ramdisk/ueventd.rc:root/ueventd.rc \ $(LOCAL_PATH)/fstab.qcom:root/fstab.qcom1234567891011121314

切勿生搬硬套，因为每个机型不一样。

假如编译出来的init不能用的话(请做完后面的显示部分适配后才能判断是否可用)，可以把官方的init程序也按照这个方法添加进去 
如果使用了官方的init，那么charger最好也改成官方的(关机充电相关) 
device.mk里去掉

#Charger PRODUCT_PACKAGES += \ charger \ charger_res_images1234

然后加上官方ramdisk里的charger以及res下的图片目录，就按照官方ramdisk目录结构来添加 
泛泰的话，这2者都还算标准 
但LG就比较奇异了，充电图片在在system\vendor\etc\chargerimages里，这个后面可以添加到proprietary-blobs.txt 
而charger程序则在sbin/ chargerlogo 
总之读者必须随机应变，毕竟每个机型都不一样 
最终这一步要做到make出来的boot/ramdisk与官方的boot/ramdisk一样就行

九、微调ramdisk

接下来要对ramdisk做一些小小的修改，这里讲几个重要修改点，当然这也是每个机型不一样，读者得靠自己多试验总结才行 
以泛泰为例

1.修改init.qcom.rc

# import cne init file on post-fs export LD_PRELOAD /system/lib/libNimsWrap.so123

cm等第三方rom经常去掉cne服务，故可以把这段删除 
有些机型可能不叫作init.qcom.rc，那么读者可以grep –r “libNimsWrap”来找，例如LG的F200就叫做init.grand-common.rc

2.修改init.rc

mkdir /cache 0770 system cache 
改成 
mkdir /cache 0771 system cache

chmod 0770 /cache 
改成 
chmod 0771 /cache

# create dalvik-cache, so as to enforce our permissions mkdir /data/dalvik-cache 0771 system system12

改成

mkdir /data/dalvik-cache 0771 system system chown system system /data/dalvik-cache chmod 0771 /data/dalvik-cache123

如果官方还加载了preload分区，也可以整段去掉，比如类似如下的语句 
mount ext4 /dev/block/mmcblk0p13 /preload rw remount 
前后可能还有一些分区检查，复制文件的语句 
preload分区是存放一些出厂预置软件或资源的，对于aosp则完全无用

删除自恢复recovery服务

service flash_recovery /system/etc/install-recovery.sh class main oneshot123

3.修改init.target.rc和fstab.qcom

这2个文件相互配合用于加载各分区 
需要注意的是，这2个文件名称也不是固定，而且有的机型需要修改，有的机型不需要修改 
比如泛泰的需要修改，而LG则无需修改 
这里以泛泰为例，先看init.target.rc 
on fs段

wait /dev/block/platform/msm_sdcc.1/by-name/system mount ext4 /dev/block/platform/msm_sdcc.1/by-name/system /system ro barrier=112

这个语句用于加载system分区

wait /dev/block/platform/msm_sdcc.1/by-name/cache exec /system/bin/mmcblk_utils ext4 /dev/block/platform/msm_sdcc.1/by-name/cache exec /system/bin/e2fsck -p /dev/block/platform/msm_sdcc.1/by-name/cache mount ext4 /dev/block/platform/msm_sdcc.1/by-name/cache /cache nosuid nodev barrier=11234

这个语句用于加载cache分区

wait /dev/block/platform/msm_sdcc.1/by-name/userdata exec /system/bin/mmcblk_utils ext4 /dev/block/platform/msm_sdcc.1/by-name/userdata exec /system/bin/e2fsck -p /dev/block/platform/msm_sdcc.1/by-name/userdata123

这个语句用于加载userdata分区

这些语句用工具检查了分区，但我们可以不需这种加载形式，把这些语句都删除 
把加载语句放到fstab.qcom里

/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 rw,barrier=1 wait /dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 nosuid,nodev,barrier=1 wait,check /dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 nosuid,nodev,barrier=1,noauto_da_alloc wait,check,encryptable=footer,length=-1638412345

需要注意的是，官方的userdata区加载语句还多了encryptable=/persist/metadata这样的结尾，估计是用来加密分区的，我们也把它去掉

4.去掉LG加密服务(此项仅针对LG，泛泰无需)

适配一切都是灵活且多变的，如果碰到困难，读者请无需气馁，多试即可 
下面以LG F200的ramdisk为例，修改并去掉一些无用的东西 
修改init.grand-common.rc，去掉import init.lge.log.rc 
修改init.rc，去掉import /init.lge.early.rc，去掉import /init.lge.rc 
然后删除如下文件 
init.lge.early.rc 
init.lge.log.rc 
init.lge.rc 
lgdms.fota.rc 
lgdms.fota_update.rc

十、build.prop修改

device/pantech/a870/system.pro这个文件添加的语句，最后会生成到build.prop里 
我们先把这个文件清空，把官方build.prop中间那段写到这个文件里，读者自己试着编译看看就知道如何编写这个文件了。

当读者把本篇文章的内容实践完成时，就已经算是入门了。

编译出来的rom肯定不能启动，但可以尝试刷到手机里看看反应，如果device名称不符合还得先去掉机型验证或自己编译一个recovery，因为视频和音频部分还未适配，现在仅仅是做个热身而已。

小白就不要尝试了，以免变砖，话又说回来，即使做为rommer难免会失手让手机变砖的时候，常在河边站哪有不湿鞋。

所以作为rommer并非大家想象中那么酷，小朋友们切勿模仿。

1 0




CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(5)：显示、NFC、overlay

发表于2015/2/22 19:13:39  1791人阅读

分类： android

从这一篇开始，稍微有点技术含量，此篇是后续适配的基础，请读者务必掌握。

一般适配是以一项一项功能来进行的，笔者一般遵循显示&NFC->音频->通信->wifi->蓝牙->传感器->摄像头->GPS->其它，这样的顺序进行适配调试。 
当然高手一下子全搞定也是可以的，不过既然要写成教程，就必须一部分一部分来讲。 
如果读者在适配到某一部分碰到问题时，可以暂时跳过解决不了的问题，先继续下一部分的适配。 
为何从显示部分开始呢，因为显示部分不能用的话，无法进到手机系统界面，看不到界面当然不开森。如果这部分搞不定，那后续也就不用适配了。 
然后是音频，音频是重点，也是整个rom的难点，这部分需要有些编程基础才容易理解。 
音频对于msm-aosp来讲是难点，但对于cm来讲则不是，因为cm开发团队都已经帮大家改好代码了。 
接着是通信，因为通话需要调用音频，所以音频得放在通信之前搞定。

最后要讲的是，适配与插桩不一样的地方，插桩主要是看log修bug。 
而编译出来的rom在代码上则没什么可修，只有缺lib或需要改配置重新编译而已。

一、ROM功能自测

正规地讲，软件的开发与测试分开的，但在前期开发时，rommer只能自己做测试 
所以做业余rommer一点都不酷，相反是很苦逼的。 
于是，读者在适配过程中得自己做好rom基础功能的自测，笔者稍微改动了乐蛙开发组提供的表格，给读者做个示范：http://download.csdn.net/detail/benjaminwan/8452181 
￼
硬件功能的测试，必须在手机里安装相应的apk来做，这里推荐2个：z硬件测试、安兔兔评测

二、vendor-maker

有许多服务程序、配置、lib需要从官方rom里提取，所以首先需要一个vendor-maker脚本 
当然读者也可以选择把这些东西都集成到device里，但实在是没有必要

1.下载地址

http://download.csdn.net/detail/benjaminwan/8452201 
包含2个sh脚本，以及一个txt文件 
这里仍然以泛泰a870为例 
把文档解压缩，得到3个文件，这3个文件都放到device/pantech/a870里 
然后赋予2个sh执行权限 
chmod a+x *.sh

2.配置要点

先把官方rom的system文件夹解压放到linux里，这里以泛泰A870为例 
笔者的路径是这样/opt/IM-A870L_S1235210/system 
system下只要留下bin、etc、lib、usr、vendor这几个文件夹就行了

首先是extract-files.sh 
VENDOR=pantech 
DEVICE=a870 
读者有必要自己修改这2行机型信息 
然后是这句复制语句，改为读者自己的放置路径 
cp /opt/IM-A870L_S1235210/system/FILEBASE/$FILE

然后是setup-makefiles.sh 
VENDOR=pantech 
DEVICE=a870 
和上面一样读者自行修改

最后是proprietary-blobs.txt 
这个文件填入需要从官方rom里提取的文件 
每一行一个文件，行首加#号的话就是注释

如何使用呢？ 
首先必须修改device/pantech/a870/a870.mk增加引用 
在文件底部增加一行 
$(call inherit-product-if-exists, vendor/pantech/a870/a870-vendor.mk)

然后在device/pantech/a870下打开终端执行 
./extract-files.sh 
每次更改了proprietary-blobs.txt都必须重新执行一次此脚本 
成功执行的话，终端没有任何提示，如果有提示则可能是找不到某个文件，根据提示读者也很容易从proprietary-blobs.txt里找到问题 
脚本执行完后，会在vendor/pantech/a870里生成相应的文件

三、显示部分的适配与调试

因为内核部分无需修改，那么这部分的内容就轻松多了。 
只要通过修改配置编译出正确的硬件抽象层hw，再配合firmware以及Adreno Llib一般就行了。

1.修改BoardConfig.mk

去除TARGET_HARDWARE_3D := false 
确保有如下项目

# Graphics USE_OPENGL_RENDERER := true TARGET_USES_ION := true TARGET_USES_OVERLAY := true TARGET_USES_C2D_COMPOSITION := true NUM_FRAMEBUFFER_SURFACE_BUFFERS := 3 TARGET_DISPLAY_INSECURE_MM_HEAP := true BOARD_EGL_CFG := device/ pantech/a870/egl.cfg12345678

对于任何不知道用途的项目，都可以用grep –r “项目名称”来查找到对应的代码位置，读者可以自行了解。

2.修改proprietary-blobs.txt

把官方rom的system/etc/firmware下所有内容加入#etc小节

接下来这些是额外的内容，虽然与显示部分无关，但也放到这里来一起讲 
顺便把官方rom的system/etc下所有xxx.sh文件加入#etc小节 
其它的还有如下文件夹，保持与官方rom一样即可： 
etc/bluetooth 
etc/dhcpcd 
etc/permissions 
etc/snd_soc_msm 
以及如下文件，有些手机可能没有或不一样，如果不确定，多出来也不要紧： 
etc/media_codecs.xml 
etc/media_profiles.xml 
etc/quipc.conf 
etc/sap.conf 
etc/sec_config 
etc/thermald-8960.conf 
etc/vold.fstab

usr目录也一样，请保持与官方rom一样即可，添加到#usr小节

还有一个容易漏掉的目录是lib/modules目录，这个文件夹里比官方rom缺少的文件补充进去，同名文件则无需替换，添加到#modules小节

最后找一找官方rom里有没有如下文件，有的就取消注释

#display #vendor/lib/egl/eglsubAndroid.so #vendor/lib/egl/libEGL_adreno.so #vendor/lib/egl/libGLESv1_CM_adreno.so #vendor/lib/egl/libGLESv2_adreno.so #vendor/lib/egl/libGLESv2S3D_adreno.so #vendor/lib/egl/libq3dtools_adreno.so #vendor/lib/libadreno_utils.so #vendor/lib/libC2D2.so #vendor/lib/libc2d2_a3xx.so #vendor/lib/libc2d2_z180.so #vendor/lib/libCB.so #vendor/lib/libgsl.so #vendor/lib/libllvm-a3xx.so #vendor/lib/libllvm-arm.so #vendor/lib/libOpenCL.so #vendor/lib/libOpenVG.so #vendor/lib/libsc-a2xx.so #vendor/lib/libsc-a3xx.so12345678910111213141516171819

一般来讲， msm8960会比apq8064少几个a3xx.so

小知识：读者可以自己对比cm11源代码的hardware/qcom/下的display/msm8960与display-caf文件夹(也就是对比一下非caf与caf之间的区别) 
￼
可以看出caf多了一个libvirtual，如果读者的手机官方rom里system/lib有libvirtual.so，就说明是手机的官方内核是caf内核

3.执行vendor-maker脚本重新生成vendor

重新编译rom！ 
这次编译如果成功完成，那么尝试刷入手机，就应该能启动看到启动器了。 
如果进不到系统，显示phone fc的话，可以编辑build.prop，去除对通信lib的调用 
可以把中间的整段删掉，包括底部的 
ro.vendor.extension_library=/system/lib/libqc-opt.so 
这样就可以顺利入桌面了，这时读者可以装个安兔兔跑个分看看显示驱动是否正常了。 
这时进入设置可能会fc，因为nfc等还没有正确配置造成的，请读者无需着急

四、增加NFC配置

1.修改device.mk

增加如下语句

# NFC packages PRODUCT_PACKAGES += \ libnfc \ libnfc_jni \ Nfc \ Tag \ com.android.nfc_extras # NFCEE access control ifeq ($(TARGET_BUILD_VARIANT),user) NFCEE_ACCESS_PATH := $(LOCAL_PATH)/nfc/nfcee_access.xml else NFCEE_ACCESS_PATH := $(LOCAL_PATH)/nfc/nfcee_access_debug.xml endif # NFC access control + feature files + configuration PRODUCT_COPY_FILES += \ $(NFCEE_ACCESS_PATH):system/etc/nfcee_access.xml \ frameworks/native/data/etc/com.android.nfc_extras.xml:system/etc/permissions/com.android.nfc_extras.xml \ frameworks/native/data/etc/android.hardware.nfc.hce.xml:system/etc/permissions/android.hardware.nfc.hce.xml \ frameworks/native/data/etc/android.hardware.nfc.xml:system/etc/permissions/android.hardware.nfc.xml123456789101112131415161718192021

2.补齐nfc文件

把提供的3个nfc文件解压到device/pantech/a870 
http://download.csdn.net/detail/benjaminwan/8452231 
最终的目录结构是device/pantech/a870/nfc/xxx文件

3. 修改proprietary-blobs.txt

把这2个文件添加到proprietary-blobs.txt 
lib/hw/nfc.default.so 
vendor/firmware/libpn544_fw.so

然后重新编译，重新刷机吧

五、overlay

device/pantech/a870/overlay里存放的是一些xml配置值 
这里笔者提供泛泰a870的仅供读者参考，就不再细说了 
http://download.csdn.net/detail/benjaminwan/8452511

请读者务必反编译参考官方rom的framework-res.apk等来修改 
这些配置关系到apn、电源配置、tf卡加载、otg加载、信号制式、呼吸灯颜色、屏幕最低亮度、wifi热点等等，每个手机不同。

六、启动后查找缺少的公共lib

按照第二篇文章后部介绍的调试方法，通过eclipse实时查看lib功能，过滤关键字为lib，查找缺少的lib文件 
一般缺lib会以这种方式提示： 
dlopen failed: could not load library “libsensor1.so” needed by “sensors.msm8960.so”; caused by library “libsensor1.so” not found 
就看此行结尾处，libsensor1.so这个即是缺的lib

然后用第二篇文章提到的adb命令工具，adb root，adb remount 
再用传送工具，把官方rom的对应lib传送的手机里

再重启手机，再以这种方式查找缺的lib，直到不再缺lib为止

这些lib都必须记录下来，最后添加到proprietary-blobs.txt

1 0


CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(6)：音频

发表于2015/2/22 19:59:17  1503人阅读

分类： android

这一篇是全系列文章的重点，故笔者会多啰嗦一些原理，多问几个为什么，请读者见谅。

笔者以android 4.4.2_r1 KOT49H为例的msm-aosp来适配，此文章则需要cm的代码来辅助理解音频的配置 
请读者自行下载cm的源代码，最好与自己下载的msm-aosp相近。 
例如与笔者这个相近的就是cm11-m4~m7，那么笔者就下载了cm11-m7 KVT49L的代码来参考。 
本文用到的仅仅是源码目录下的hardware目录，所以笔者也单独提供了这个目录的压缩文档，以方便读者实践： 
http://download.csdn.net/detail/benjaminwan/8452249

一、对比cm与msm-aosp的hardware/qcom目录

记得对比选项里要钩基础规则对比 
￼
左边为cm的hardware，右边边为msm-aosp的hardware 
首先请读者思考一个问题： 
分别把左边的audio与右边的audio文件夹对比，以及左边的audio-caf与右边的audio文件夹对比，这2种情况下，左边哪个文件夹与右边代码最相似。 
当然读者会发现左边的audio-caf代码与右边的audio最为相似 
如果读者也同步了google-aosp的代码，就会发现cm的audio文件夹与google-aosp的audio文件夹最相似。 
从这里我们可以总结得出：cm实际上集成了google以及高通，二者的audio代码 
那么就有了第二个问题，cm如何通过配置来选择使用哪种音频代码？

二、对比audio目录

接下来就把cm的qcom/audio-caf与msm-aosp的qcom/audio目录对比 
以下文章的内容都默认以cm的audio-caf来讲解了 
对比audio/Android.mk 
￼
首先可以看出cm比aosp多了这个语句 
ifeq ($(TARGET_QCOM_AUDIO_VARIANT),caf)
这个语句作用就是cm用来选择是audio还是audio-caf的 
解释一下：如果在BoardConifg.mk里有TARGET_QCOM_AUDIO_VARIANT := caf那么就选择audio-caf文件夹来编译，相反，如果不配置此项，则默认使用audio文件夹

分析完左边的cm，再来研究右边的msm-aosp 
cm11多出来的是一些其它平台的代码，msm8660,msm8610之类的 
接下来只看红框中的共通项

ifeq ($(BOARD_USES_LEGACY_ALSA_AUDIO),true) include $(MY_LOCAL_PATH)/legacy/Android.mk else include $(MY_LOCAL_PATH)/hal/Android.mk endif12345

这是一个选择语句，那么到底该选择legacy文件夹或者是hal文件夹呢？

接下来要讲一个小知识，音频hw实际上分为2种，如上看到的legacy以及hal 
官方rom的话，msm8960平台使用legacy，而msm8974平台使用hal 
来讲讲这2种hw驱动在官方rom里可以看到什么区别 
legacy驱动，需要在etc里有个snd_soc_msm文件夹，里面放音频配置文件 
而hal驱动，则会在etc下有个mixer_patchs.xml 
而且legacy的系统lib下没有libaudioroute.so，相反hal驱动则有 
举个例子，泛泰A910，msm8974平台 
￼
msm8960平台的例子，请读者自己打开官方rom查看一下便知。

接下来第二个提示要点，对比cm与msm-aosp的hal文件夹，可以发现msm-aosp的hal文件夹缺了许多代码并感觉残缺不全，对，因为我们当前同步的msm-aosp代码仅针对msm8960平台，所以实际上hal文件夹代码是缺失的。 
如果读者后续也同步了msm8974平台的msm-aosp，那么对比一下就知道怎么回事了。

回答前面提到的问题，从官方rom得到的提示以及对比cm的hal文件夹，我们应该选择legacy文件夹来编译 
所以必须在BoardConfig.mk里添加BOARD_USES_LEGACY_ALSA_AUDIO := true

小知识：因为cm集成了全部的音频代码(包括google、高通各个平台)，所以编译cm时，即使msm8960平台也可以选择hal来编译。

三、对比legacy文件夹

￼
cm还集成了msm7x30以及msm8660平台的代码，这2个可以不管 
只看右边红框的共通项 
从逻辑上分析，legacy文件夹下的Android.mk里只有这么一个选择项 
那么它就必须要选中，否则上一级选中了legacy文件夹就失去了作用 
所以Boardconfig.mk里就必须要有 
BOARD_USES_ALSA_AUDIO := true

在原来的Boardconfig.mk里，高通在范例里配置了 
BOARD_USES_GENERIC_AUDIO := true，这行可以删掉了 
这是android自带的通用音频驱动，当然无法正确驱动高通平台

四、对比4个文件夹

￼
4个文件夹，有3个不一样，那么从最简单的、相同的那个开始看 
audiod文件夹是最简单的，而且与cm11的代码完全一样

五、对比audiod文件夹

￼
截图里面3个红框的部分是一般我们需要注意或者需要看的地方 
第一个红框：选择语句就不再解释了 
第二个红框：代表依赖的共享lib，也就是说编译这个audio依赖这4个lib 
第三个红框：LOCAL_MODULE:= audiod，这句表示此模块编译后生成的文件名为audiod

那么问题来了，这个audiod需要编译吗？ 
提示： 
1.官方rom是我们唯一可以参考的； 
2.LOCAL_MODULE代表编译后这个模块最终生成的文件名； 
3.笔者也不知道读者的机型是否需要编译audiod模块；

OK，答案揭晓了： 
既然知道这个模块编译之后，文件名叫做audiod，那么在官方rom里找一找，有没有叫做audiod的文件，如果没有就是不需要，如果有就是需要 
当然，泛泰a870是不需要的，所以这部分就不添加任何语句

六、对比mm-audio文件夹

这个文件夹基本上与cm一样，仅有2处稍有区别，cm11的更改肯定有它的道理，读者只要知道与cm有些许区别就行。

这个文件夹下的Android.mk里，并没有提供选择题 
include $(call all-subdir-makefiles) 
这个就是全选，不需要我们再手工配置指定

七、对比libalsa-intf文件夹

重点来了 
￼
￼
看上下2个截图，左右的区别，重点在于TARGET_USES_QCOM_MM_AUDIO这个配置项的形式不同。 
右边的代码形式是ifeq ($(strip $(TARGET_USES_QCOM_MM_AUDIO)),true) 
左边的代码形式是ifneq ($(TARGET_USES_QCOM_COMPRESSED_AUDIO),false) 
为何cm与msm-aosp有差异，或者cm为何要从ifeq更改为 ifneq？ 
读者理解了cm为何要这么改，后面的最后一个文件夹也就能立刻理解了

现在讲解一下： 
ifneq (AAA,false) 
这种语句，在不配置AAA或AAA不等于false(也就是等于true)时，就满足if条件 
换句话来讲也就是cm改成了：即使不配置，也默认启用此项 
因为cm代码是面对的所有机型，那么最终就说明这个项目对所有机型都是有用的 
除非你在BoardConfig.mk里手工指定了这项为fasle，否则默认都是启用的

ok，回到右边msm-aosp的代码 
msm-aosp这个选项与cm语法不一样，它确实要求我们选择是否配置 
但因为从cm代码得知，这个项目一般都是需要选中的，所以我们需要在BoardConfig.mk里增加TARGET_USES_QCOM_MM_AUDIO := true

八、对比alsa_sound文件夹

这是音频最后一个文件夹 
￼
从截图我们可以看到cm做了许多更改，主要是把ifeq(true)改为ifneq(false)的形式 
那么从前一个要点可以知道，这种形式的更改，会导致不配置也默认启用。 
ok，进入正题 
cm改动的项目，都是aosp必须打开的项目，所以最终还要在BoardConfig.mk里的#Audio节里添加

QCOM_ACDB_ENABLED := true QCOM_ANC_HEADSET_ENABLED := true QCOM_AUDIO_FORMAT_ENABLED := true QCOM_CSDCLIENT_ENABLED := true QCOM_PROXY_DEVICE_ENABLED := true QCOM_OUTPUT_FLAGS_ENABLED := true QCOM_USBAUDIO_ENABLED := true QCOM_ADSP_SSR_ENABLED := true QCOM_FLUENCE_ENABLED := true QCOM_TUNNEL_LPA_ENABLED := true12345678910

九、音频部分总结

BOARD_USES_GENERIC_AUDIO := true，这行删除 
添加如下内容

BOARD_USES_LEGACY_ALSA_AUDIO := true BOARD_USES_ALSA_AUDIO := true TARGET_USES_QCOM_MM_AUDIO := true QCOM_ACDB_ENABLED := true QCOM_ANC_HEADSET_ENABLED := true QCOM_AUDIO_FORMAT_ENABLED := true QCOM_CSDCLIENT_ENABLED := true QCOM_PROXY_DEVICE_ENABLED := true QCOM_OUTPUT_FLAGS_ENABLED := true QCOM_USBAUDIO_ENABLED := true QCOM_ADSP_SSR_ENABLED := true QCOM_FLUENCE_ENABLED := true QCOM_TUNNEL_LPA_ENABLED := true12345678910111213

十、关于编译错误的处理

改完BoardConfig.mk就可以开始重新编译了 
在编译的过程中可能会碰到几次编译错误

1.缺intermediates错误

需要目标"out/target/product/a870/obj/SHARED_LIBRARIES/libacdbloader_intermediates/export_includes”

对于这种错误，需要在device/pantech/a870/Android.mk里添加

$(shell mkdir -p $(OUT)/obj/SHARED_LIBRARIES/libacdbloader_intermediates/) $(shell touch $(OUT)/obj/SHARED_LIBRARIES/libacdbloader_intermediates/export_includes)12

注意：linux是区分大小写的，OUT必须是大写 
这个语句是用来hack的，让编译系统误以为我们有libacdloader源代码(但实际上我们没有，我们只有从官方rom里提取的lib)

然后修改proprietary-blobs.txt添加libacdbloader.so 
然后修改setup-makefiles.sh，取消下面语句的注释，用于把proprietary-blobs.txt提取的lib复制到obj目录

PRODUCT_COPY_FILES += \\ $OUTDIR/proprietary/lib/libacdbloader.so:obj/lib/libacdbloader.so12

然后重新生成vendor，再继续编译。

如果碰到其它音频lib文件提示类似的错误，请读者依葫芦画瓢处理。

2.源码编译错误

编译停下来的地方基本上不是发生错误的地方，在终端里搜索关键字error，选向上搜索，找到真正发生错误的地方。 
其中一个是libalsa-intf\alsa_ucm.c，错误提示是fatal error: acdb-loader.h : NO such file or directory 
对比cm 
￼
之前说过，我们没有libacdbloader的源代码，所以这个acdb-loader.h也就无法提供了 
而cm则更改了这句代码，但msm-aosp需要这样改： 
右边注释掉，注意，C代码双斜杠是注释//

//#if defined(QC_PROP) // #include "acdb-loader.h" //#else //#endif1234

最终是这个样子 
￼

另一个错误发生在：alsa_sound/AudioHardwareALSA.cpp 
‘PROXY_OPEN_RETRY_COUNT’ was not declared in this scope 
错误指向这里 
￼
参考cm，加上#ifdef QCOM_USBAUDIO_ENABLED和#endif即可

十一、声音配置微调

对于某些有双mic降噪功能的手机，一般会在手机顶部以及底部各有一个mic。 
正常底部mic作为主mic，要大声，顶部mic作为降噪mic，要小声。 
这个可以用z硬件测试的mic测试功能，分别对着顶部和底部mic讲话，看声音幅度就知道是否有颠倒。 
如果颠倒了，我们要调整build.prop里的配置值来修正 
persist.audio.handset.mic=digital 
改成 
persist.audio.handset.mic=analog 
或者反之，请读者自行试验

十二、进阶调试

1.耳机插入检测的方式

andoird一共有2种检测方式 
方法一：由内核负责检测，设备驱动名为h2w，一般会在/sys/class/switch或/sys/devices/virtual/switch 
方法二：由音频系统负责检测，msm8960就属于此种情况，实际由PM8921的GPIO38脚负责 
如何知道手机是哪种检测方式？用排除法吧 
查看logcat信息： 
W/WiredAccessoryObserver( 627): This kernel does not have wired headset support 
这样的语句即代表内核不支持耳机检测，所以只能由音频系统来检测了。

2.耳机插入检测GPIO查看

原理图下载：http://download.csdn.net/detail/benjaminwan/8453547 
查看原理图第18页 
￼
PM8921的GPIO38脚，标签ANC_HS_DET即为耳机检测

开adb shell，取得root权限 
cat /sys/kernel/debug/gpio 
可以看到分成好几段，这是按功能把芯片引脚区分成几个段而已

GPIOs 0-151, platform/msmgpio, msmgpio: GPIOs 152-195, platform/pm8xxx-gpio, pm-gpio: GPIOs 196-207, platform/pm8xxx-mpp.0, pm8xxx-mpp: GPIOs 208-211, platform/pm8xxx-mpp.1, pm8xxx-mpp:1234

我们要查看原理图里的PM8921的GPIO38脚，在debug信息里如何换算成第几个GPIO呢？ 
看上面的分段信息，第一段即MSM8960为GPIOs 0-151，共有151脚，第二段就是PM8921，我们要PM8921的第38脚，那么就是151+38= 189脚

查看GPIOs 152-195, platform/pm8xxx-gpio, pm-gpio:这一段 
当耳机插入时为高电平 
gpio-189 (-- ) in hi 0x05 0x10 0x2a 0x30 0x40 0x58 
当耳机未插入时为低电平 
gpio-189 (-- ) in lo 0x05 0x10 0x2a 0x30 0x40 0x58

3.输入设备事件查看

开adb shell，取得root权限

cat /proc/bus/input/devices I: Bus=0000 Vendor=0000 Product=0000 Version=0000 N: Name="apq8064-tabla-snd-card Button Jack" P: Phys=ALSA S: Sysfs=/devices/platform/soc-audio.0/sound/card0/input2 U: Uniq= H: Handlers=kbd event2 cpufreq B: PROP=0 B: EV=3 B: KEY=f8 4 0 0 0 c0000 0 0 0 I: Bus=0000 Vendor=0000 Product=0000 Version=0000 N: Name="apq8064-tabla-snd-card Headset Jack" P: Phys=ALSA S: Sysfs=/devices/platform/soc-audio.0/sound/card0/input3 U: Uniq= H: Handlers=event3 cpufreq B: PROP=0 B: EV=21 B: SW=1c0541234567891011121314151617181920

可以找到如上类似的信息，可能因手机不一样而不一样 
其中Headset Jack即为耳机插入检测 
Button Jack是耳机线控按钮检测

从信息得知 
耳机检测设备路径/devices/platform/soc-audio.0/sound/card0/input3 
对应的Handlers为event3

我们来测试一下： 
cat /dev/input/event3 
执行完命令后就放着，然后插入或拔出耳机，命令行会输出一些调试信息，但我们没有专用的查看工具所以无法查看具体信息，ctrl+C结束

耳机线控按钮检测设备路径/devices/platform/soc-audio.0/sound/card0/input2 
对应的Handlers为event2 
cat /dev/input/event2 
同样地，按下耳机线控按钮，命令行会输出一些调试信息

0 0





CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(7)：信号通讯

发表于2015/2/22 20:04:38  1304人阅读

分类： android

前面的显示与音频是难关，通信的适配比较简单，只需要一些技巧即可。

一、补齐通讯lib

先查看官方rom的system/bin里有没有cpmgrif这个程序，如果没有就下载笔者提供的吧 
http://download.csdn.net/detail/benjaminwan/8452331

把cpmgrif传送到手机system/bin里 
连上调试，打开一个adb shell并取得root权限 
执行cpmgrif 
按照命令行里的提示把缺少的lib传送进去补齐，记得记录下来并添加到proprietary-blobs.txt的#rild小节

二、补齐系统服务

现在system/bin中仍然缺少许多系统服务，对比官方rom与编译出来的aosp系统 
把bin文件夹下比官方rom少的程序传送进去，并按照上面的方法，每传送一个执行一下，补齐lib 
记得记录下来并添加到proprietary-blobs.txt里，最好是自己根据程序名称，命名一个小节，例如：

#port-bridge lib/libCommandSvc.so12

注意：cne不需要添加，因为我们在前面的教程里提到，在init.qcom.rc里去掉了cnd服务支持，而且在build.prop里的persist.cne.feature=1也必须改为0

这纯粹是体力活，没什么技术含量。 
这些做完后，重启一下手机，参照官方rom的build.prop中间那段加上通信lib的调用 
此时，应该就有信号了。

等读者全部适配完成以后，可以尝试做减法，再通过试验，把bin中的某些无用服务去除。

小知识：官方rom中有些服务是用于wifi、蓝牙初始化的，从nv中读mac地址等等 
但cm等第三方rom通过编写bdAddrLoader、conn_init等程序来实现这些功能(例如nexus4)。 
这显然不适合初学者，所以初学者还是老实地用官方bin并把lib补齐来用就行了。 
LG手机用来初始化wifi的服务是system/bin/atd 
泛泰手机是system/bin/pantech_server

三、重新编译

proprietary-blobs.txt添加了许多内容，重新生成vendor，重新编译 
参考前一篇结尾的错误处理，如果编译系统提示缺少intermediates，请读者依葫芦画瓢处理

四、build.prop配置项

build.prop里有一些选项与通信网络相关

rild.libpath=/system/lib/libril-qc-qmi-1.so rild.libargs=-d /dev/smd0 persist.rild.nitz_plmn= persist.rild.nitz_long_ons_0= persist.rild.nitz_long_ons_1= persist.rild.nitz_long_ons_2= persist.rild.nitz_long_ons_3= persist.rild.nitz_short_ons_0= persist.rild.nitz_short_ons_1= persist.rild.nitz_short_ons_2= persist.rild.nitz_short_ons_3= ril.subscription.types=NV,RUIM ro.vendor.extension_library=/system/lib/libqc-opt.so12345678910111213

与网络制式有关

ro.telephony.default_network=9 telephony.lteOnGsmDevice=1可以用联通3G 或 telephony.lteOnCdmaDevice=1可以用联通4G1234

以下这2项与数据网络有关

ro.use_data_netmgrd=true ro.ril.transmitpower=true12

五、数据网络

一般来讲，有信号时，数据网络应该就正常了。 
但不排除某些国外手机使用了非标准的通讯层代码，导致数据网络不可用 
笔者只适配过韩版机，所以这方面的经验不多，就无法提供更多参考了。 
已知的有LG部分韩版机可能会在通讯层里增加韩文code编码造成问题 
如果碰到这方面的问题，有编程经验的读者也无需担心，等读者有能力适配cm后，参考cm的通信层代码来修改。

这里提供一个笔者适配修改过的例子： 
韩版机LG F160 4.1系统的msm-aosp适配时碰到的开启数据网络出错问题的解决，这个虽然是4.1的例子且4.4系统不能直接参考了，但读者多了解一下总也没什么不好。 
下载：http://download.csdn.net/detail/benjaminwan/8452417 
其中stock代表aosp原始代码，f160代表修改后代码

0 0




CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(8)：wifi与蓝牙

发表于2015/2/22 20:17:00  1386人阅读

分类： android

wifi与蓝牙放在一起，因为这两者的芯片供应商有2种： 
高通(qcom)或博通(brcm) 
而且都是成对一起使用某个厂商的芯片，不会出现wifi是高通，蓝牙是博通的情况

一、如何判断wifi芯片供应商

高通wifi芯片： 
在system\etc\firmware\wlan\prima\里有WCNSSxxxx类似的文件，这些是固件 
在system\lib\modules\prima里有prima_wlan.ko，这是wifi驱动 
wifi驱动也有不以模块形式加载，而直接集成在内核里的

博通wifi芯片： 
在system\etc\firmware\里有fw_bcmdhdxxx.bin类似的文件，这些是固件 
在system\etc\wifi里有bcmdhd.cal配置文件

二、如何判断蓝牙芯片供应商

高通蓝牙： 
system\etc\init.qcom.bt.sh有初始化蓝牙的相关脚本 
system\bin里有btnvtool蓝牙工具

博通蓝牙： 
能找到BCM4334B0_002.001.013.1804.1954.hcd这样的文件 
或者有brcm_patchram_plus这个程序

三、在BoardConfig.mk里增加高通wifi项

# Wifi BOARD_HAS_QCOM_WLAN := true BOARD_WLAN_DEVICE := qcwcn WPA_SUPPLICANT_VERSION := VER_0_8_X BOARD_WPA_SUPPLICANT_DRIVER := NL80211 BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_$(BOARD_WLAN_DEVICE) BOARD_HOSTAPD_DRIVER := NL80211 BOARD_HOSTAPD_PRIVATE_LIB := lib_driver_cmd_$(BOARD_WLAN_DEVICE) WIFI_DRIVER_MODULE_PATH := "/system/lib/modules/wlan.ko" WIFI_DRIVER_MODULE_NAME := "wlan" WIFI_DRIVER_FW_PATH_STA := "sta" WIFI_DRIVER_FW_PATH_AP := "ap"123456789101112

在本例里，必须从官方rom里提取wlan.ko放到/system/lib/modules/wlan.ko 
然后参考官方卡刷包的刷机脚本updater-script 
在device/pantech/a870/Android.mk里添加如下语句

# Create wlan firmware links $(shell mkdir -p $(TARGET_OUT_ETC)/firmware/wlan/prima; \ ln -sf /data/misc/wifi/WCNSS_qcom_cfg.ini $(TARGET_OUT_ETC)/firmware/wlan/prima/WCNSS_qcom_cfg.ini; \ ln -sf /data/misc/wifi/prima.bin $(TARGET_OUT_ETC)/firmware/wlan/prima/prima.bin) # Create wlan module links $(shell mkdir -p $(TARGET_OUT)/lib/modules; \ ln -sf /system/lib/modules/prima/prima_wlan.ko $(TARGET_OUT)/lib/modules/wlan.ko)12345678

这些语句用于创建链接 
最终编译后会在updater-script里生成如下语句：

symlink("/data/misc/wifi/WCNSS_qcom_cfg.ini", "/system/etc/firmware/wlan/prima/WCNSS_qcom_cfg.ini"); symlink("/data/misc/wifi/prima.bin", "/system/etc/firmware/wlan/prima/prima.bin"); symlink("/system/lib/modules/prima/prima_wlan.ko", "/system/lib/modules/wlan.ko");123

另外值得提醒的是，WCNSS_qcom_cfg.ini这个文件，aosp或其它第三方rom必须放在system\etc\wifi才会起作用，但官方ROM却有可能放在system\etc\firmware\wlan\prima里，至于需要放在哪个路径才行，请读者自行试验。

四、在BoardConfig.mk里增加博通wifi项

# Wifi BOARD_WPA_SUPPLICANT_DRIVER := NL80211 WPA_SUPPLICANT_VERSION := VER_0_8_X BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_bcmdhd BOARD_HOSTAPD_DRIVER := NL80211 BOARD_HOSTAPD_PRIVATE_LIB := lib_driver_cmd_bcmdhd BOARD_WLAN_DEVICE := bcmdhd WIFI_DRIVER_FW_PATH_PARAM := "/sys/module/bcmdhd/parameters/firmware_path" WIFI_DRIVER_FW_PATH_STA := "/system/etc/firmware/fw_bcmdhd.bin" WIFI_DRIVER_FW_PATH_AP := "/system/etc/firmware/fw_bcmdhd_apsta.bin"12345678910

然后在build.prop还必须有wifi相关的配置项，具体请参考官方rom 
例如wifi.interface=wlan0类似这种项必须有，请读者自行尝试

五、在BoardConfig.mk里增加高通蓝牙项

# Bluetooth BOARD_HAVE_BLUETOOTH := true BOARD_HAVE_BLUETOOTH_QCOM := true BLUETOOTH_HCI_USE_MCT := true BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR := device/pantech/a870/bluetooth12345

六、在BoardConfig.mk里增加博通蓝牙项

# Bluetooth BOARD_HAVE_BLUETOOTH := true BOARD_HAVE_BLUETOOTH_BCM := true BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR := device/pantech/a870/bluetooth1234

注意：博通蓝牙的话，可能msm-aosp对其支持较差，总之笔者没有成功适配过博通蓝牙功能-_-

七、修改蓝牙设备默认名称

修改device/pantech/a870/bluetooth/bdroid_buildcfg.h 
#define BTM_DEF_LOCAL_NAME "QCOM-BTD" 
这个是蓝牙默认名称，可以自己修改，比如泛泰a870可以这样改 
#define BTM_DEF_LOCAL_NAME "IM-A870"

八、高通wifi调试

当wifi不能用时，除了看log，还可以对比官方rom来做试验 
打开adb shell并取得root权限 
接下来介绍几个调试命令 
getprop wlan.driver.status 获取wlan驱动状态 
未打开wifi时是unloaded 
打开wifi后是ok

cat /proc/modules 这个用于获取当前加载的模块 
未打开wifi时 
texfat 174987 0 - Live 0x00000000 (PO) 
mwlan_aarp 3331 0 - Live 0x00000000 (PO)

打开wifi后 
wlan 3021860 0 - Live 0x00000000 (O) 
texfat 174987 0 - Live 0x00000000 (PO) 
mwlan_aarp 3331 0 - Live 0x00000000 (PO)

0 0




CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(9)：摄像头GPS传感器

发表于2015/2/22 20:24:00  1449人阅读

分类： android

一、传感器

先从最简单的传感器开始吧 
传感器这部分没有源代码，只要从官方rom里提取相关lib就行了

#sensor lib/hw/sensors.msm8960.so lib/hw/sensors_native_hal.so lib/hw/sensors_qcom.so lib/libsensor_reg.so lib/libsensor1.so lib/libyas530.so1234567

一般msm8960平台就这几个lib，其中libyas530是电子罗盘的lib

再说说找lib方法，有2种方法互补 
首先，把lib/hw/sensorxxx传送到手机，然后重启系统，通过log查看缺少的lib并补齐 
如果还缺，就用ultraedit打开lib/hw/sensorxxx，然后搜索lib关键字，找到其依赖的其它缺少的lb，在通过打开这些缺的lib再次搜索缺少的lib

补齐了所有lib后，用z硬件测试来试验所有传感器是否正常。

二、相机

1.修改BoardConfig.mk

#Camera USE_DEVICE_SPECIFIC_CAMERA := true BOARD_USES_CAMERA_FAST_AUTOFOCUS := true USE_CAMERA_STUB := true1234

提示：USE_DEVICE_SPECIFIC_CAMERA 这句意思是不编译提供的通用相机代码，我们通过使用官方lib去实现相机功能。但对于aosp来说这项不起作用，这项是给cm用的。

2.寻找相机lib

摄像头(相机)与传感器类似，但lib更多 
摄像头(相机)hw可以通过编写代码而编译出来，但显然不适合没有基础的初学者，我们只要使用官方的hw和lib就行了 
某些手机会把相机的firmware集成到boot.img里，就像泛泰CExxx.bin，那么在ramdisk就得添加相应的内容，其它手机可能不需要

首先system/lib下含chromatix的lib全都要添加，这里以泛泰a870为例

lib/libchromatix_imx074_default_video.so lib/libchromatix_imx074_preview.so lib/libchromatix_imx074_video_hd.so lib/libchromatix_imx074_zsl.so lib/libchromatix_imx091_default_video.so lib/libchromatix_imx091_preview.so lib/libchromatix_imx091_video_hd.so lib/libchromatix_imx135_default_video.so lib/libchromatix_imx135_preview.so lib/libchromatix_imx135_video_hd.so lib/libchromatix_imx135_video_hdr.so lib/libchromatix_imx135_zsl.so lib/libchromatix_mt9e013_default_video.so lib/libchromatix_mt9e013_preview.so lib/libchromatix_mt9e013_video_hfr.so lib/libchromatix_ov2720_default_video.so lib/libchromatix_ov2720_hfr.so lib/libchromatix_ov2720_preview.so lib/libchromatix_ov2720_zsl.so lib/libchromatix_ov5647_default_video.so lib/libchromatix_ov5647_preview.so lib/libchromatix_ov8825_default_video.so lib/libchromatix_ov8825_preview.so lib/libchromatix_ov8825_video_hfr.so lib/libchromatix_ov8825_video_hfr_60fps.so lib/libchromatix_ov8825_video_hfr_90fps.so lib/libchromatix_ov8825_video_hfr_120fps.so lib/libchromatix_ov8825_zsl.so lib/libchromatix_ov9726_default_video.so lib/libchromatix_ov9726_preview.so lib/libchromatix_s5k3l1yx_default_video.so lib/libchromatix_s5k3l1yx_hfr_60fps.so lib/libchromatix_s5k3l1yx_hfr_90fps.so lib/libchromatix_s5k3l1yx_hfr_120fps.so lib/libchromatix_s5k3l1yx_preview.so lib/libchromatix_s5k3l1yx_video_hd.so lib/libchromatix_s5k3l1yx_zsl.so lib/libchromatix_s5k4e1_default_video.so lib/libchromatix_s5k4e1_preview.so123456789101112131415161718192021222324252627282930313233343536373839

然后传送官方rom的lib/hw/camera.msm8960.so到手机 
并通过前面介绍的2种找lib方法来补齐所有lib 
以下同样是泛泰a870的参考

#camera mm-qcamera-daemon lib/hw/camera.msm8960.so lib/liboemcamera.so lib/libmmjpeg.so lib/libgemini.so lib/libmercury.so lib/libmmcamera_faceproc.so lib/libmmcamera_frameproc.so lib/libmmcamera_hdr_lib.so lib/libmmcamera_image_stab.so lib/libmmcamera_imx091.so lib/libmmcamera_interface.so lib/libmmcamera_interface2.so lib/libmmcamera_plugin.so lib/libmmcamera_statsproc31.so lib/libmmcamera_wavelet_lib.so lib/libadsprpc.so lib/libmmjpeg_interface.so lib/libmmstillomx.so lib/libimage-jpeg-dec-omx-comp.so lib/libimage-jpeg-enc-omx-comp.so lib/libimage-omx-common.so lib/libOlaEngine.so lib/libmorpho_easy_hdr.so lib/libVDFaceAPI.so lib/libmmipl.so1234567891011121314151617181920212223242526

最后是这个特殊的lib，如果编译出来的能用，那测试一下没问题就用编译出来的 
如果不能用就必须从官方rom提取出来替换到编译的aosp里才行 
lib/libcamera_client.so

如果这时硬件编解码相关的lib没有缺的话，就能正常使用摄像头了，顺带的，闪光灯也应该能用了。

关于此部分的内容，可以参考进阶教程： 
http://blog.csdn.net/benjaminwan/article/details/45112505

3.相机程序的分辨率支持

反编译官方的Camera程序以及自己编译相机程序进行对比 
找res\values\arrays.xml和strings.xml，类似如下这种

<string-array name="pref_camera_picturesize_entryvalues"> <item>5248x3936</item> <item>4992x3744</item>123

把支持的像素值加进去，测试好了就可以加到device/pantech/a870/overlay里

三、GPS

笔者直接改用了CM的gps代码，因为简单好用。

1.修改源代码

对比cm与 msm-aosp的hardware/qcom/gps 
gps文件夹整个替换成cm的，全！部！替！换！

然后修改hardware/qcom/gps/loc_api/Android.mk 
去掉第一行和最后一行

ifneq ($(TARGET_PROVIDES_GPS_LOC_API),true) endif#TARGET_PROVIDES_GPS_LOC_API12

修改hardware/qcom/gps/loc_api/Android.mk 
去掉第一行和最后一行

ifneq ($(TARGET_PROVIDES_GPS_LOC_API),true) endif#TARGET_PROVIDES_GPS_LOC_API12

2.修改BoardConfig.mk

# GPS TARGET_NO_RPC := true BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE := $(TARGET_BOARD_PLATFORM) 或把这句改成这样也行 BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE :=msm896012345

3.libloc_api_v02.so

如果最后没有生成libloc_api_v02.so的话，从其它手机的cm11里提取一个libloc_api_v02.so来用，最后如果测试可用后，集成到device.mk里

4.gps.conf

可以从官方rom里提取，或读者自己可以去网上找到很多优化好的配置文件

5.修改device.mk

去除原来的gps项，添加如下项目

# GPS PRODUCT_PACKAGES += \ libloc_adapter \ libloc_eng \ libloc_api_v02 \ libgps.utils \ gps.msm89601234567

6.不要使用任何官方的gps lib

这些官方lib都不要使用： 
system/lib/ liblocxxx 
vendor/lib/liblocxxx,liblocationservice,libgeofence.so 
也不要使用使用官方的lib/hw/gps.default.so 
否则会造成冲突

7.重新编译

如果正常，会生成lib\hw\gps.msm8960.so以及相关lib，然后刷机测试

0 0


CSDN博客

￼ benjaminwan

Msm8960(APQ8064)平台的MSM-AOSP-kitkat编译适配(10)：其它

发表于2015/2/22 20:32:22  1633人阅读

分类： android

本篇是此系列文章的最后一篇。

一、Power

官方rom里如果有system\vendor\lib\hw\power.qcom.so 
则可以加到proprietary-blobs.txt 
其实同版本适配时，官方rom里的多数lib都可以替换到编译出来的msm-aosp里

二、拔电池掉时间问题

CM系统的时间服务只要在BoardConfig.mk里加一个语句BOARD_USES_QC_TIME_SERVICES := true就行了，然后提取官方的lib/libtime_genoff.so来用就搞定了 
而msm-aosp则麻烦多了，它没有专门的配置项和代码 
你得先用厨房工具合并odex，把官方rom的TimeService.apk提取出来用，并放到device/pantech/a870/etc文件夹 
并在etc文件夹下新建一个Android.mk，内容如下

LOCAL_PATH:= $(call my-dir) include \$(CLEAR_VARS) LOCAL_MODULE := TimeService LOCAL_MODULE_PATH := $(TARGET_OUT)/app/ LOCAL_SRC_FILES := TimeService.apk LOCAL_MODULE_TAGS := optional LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_SUFFIX:=$(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_CERTIFICATE := platform include \$(BUILD_PREBUILT)12345678910

然后写到device.mk里

#TimeService.apk PRODUCT_PACKAGES += TimeService12

最后在proprietary-blobs.txt里添加

#TimeService.apk lib/libtime_genoff.so lib/libTimeService.so123

三、按键灯、呼吸灯

这个也是各种手机不一样，而且还必须修改代码-_- 
对于没有编程基础的读者，就直接用官方rom的system/lib/hw/lights.msm8960.so

1.首先通过调试确定各种灯的调用路径

开一个adb shell，并取得root权限

cd /sys/class/leds ls12

这样就可以列出当前有那些led设备，并记录下来
这里就以LG F200这种有实体按键的手机来举例吧

lcd背光 /sys/class/leds/lcd-backlight/brightness 红灯 /sys/class/leds/led:red/brightness 绿灯 /sys/class/leds/led:green/brightness 蓝灯 /sys/class/leds/led:blue/brightness 按键灯 /sys/class/leds/button-backlight/brightness1234567891011121314

如果读者想具体试验一下用命令控制各种灯的话，笔者介绍几个命令

echo 200 > /sys/class/leds/lcd-backlight/brightness 设置背光值为200 echo 0 > /sys/class/leds/lcd-backlight/brightness 设置背光值为0 echo 255 > /sys/class/leds/led:red/brightness 开红灯 echo 0 > /sys/class/leds/led:red/brightness 关红灯 cat /sys/class/leds/led:red/brightness查看当前的灯亮度值 cat /sys/class/leds/led:red/max_brightness查看灯的最大亮度值12345678

2.修改liblight代码

msm-aosp不像cm那样可以把liblight单独出来，所以咱就直接到源代码目录去修改 
hardware/qcom/display/liblight 
先把lights.c压缩备份一下 
开始修改lights.c，首先修改三个颜色的呼吸灯调用地址 
￼
仿照呼吸灯的行，增加一行按键灯的路径

char const*const BUTTON_FILE = "/sys/class/leds/button-backlight/brightness";12

下面的这些路径，如果读者的机型不支持(也就是没有这个路径)，那就把这些代码删掉 

在rgb_to_brightness下面添加一段按键灯的调用函数 

static int set_light_buttons(struct light_device_t* dev, struct light_state_t const* state) { int err = 0; int on = is_lit(state); pthread_mutex_lock(&g_lock); err = write_int(BUTTON_FILE, on?255:0); pthread_mutex_unlock(&g_lock); return err; }1234567891011

然后拉到文件底部增加按键背光调用入口 
￼

else if (0 == strcmp(LIGHT_ID_BUTTONS, name)) set_light = set_light_buttons;12

这就是大概的步骤，对于没有编程基础的读者来说可能比较困难 
请参考笔者提供的范例吧： 
http://download.csdn.net/detail/benjaminwan/8452531

最后，提供一个泛泰A910的呼吸灯适配例子： 
http://blog.csdn.net/benjaminwan/article/details/45112175

四、振动

这一段专门为泛泰而写 
因为泛泰全系列机型内核里的振动代码都是非标准的

1.引用syhost对此部分的解析

http://blog.csdn.net/syhost/article/details/12125971 
不论读者能否理解，咱们来实际调试一下就明白了 
老套路了，开一个adb shell，并取得root权限 
标准振动代码的手机，只要执行这句就能让手机振动起来，振动1秒 
echo 1000 > /sys/class/timed_output/vibrator/enable

而泛泰手机官方内核必须是 
echo 1311720 > /sys/class/timed_output/vibrator/enable

1311720这个值是如何得到的呢？ 
如果读者没有任何计算机基础，那么就以最直观的方式来试吧，打开window自带的计算器，使用程序员模式。 
十进制输入数值1000，切换到十六进制，按Or键，再输入140000，按等于号，并切换到十进制显示就是1311720 
简单来说，就是3E8|0x140000 = 1403E8，即，振动时间|0x140000

2.修改振动调用代码

对于cm来讲，振动代码可以BOARD_HAS_VIBRATOR_IMPLEMENTATION来自定义 
msm-aosp比较简陋啦，只好直接改代码了 
hardware/libhardware_legacy/vibrator/vibrator.c 
只要在sendit函数里添加一句timeout_ms = 0x140000 | timeout_ms;即可 

0 0

================================
登录
罗升阳 博客专家
关注
从CM刷机过程和原理分析Android系统结构
原创 2014年06月16日 01:01:48 阅读 90653
       前面101篇文章都是分析Android系统源码，似乎不够接地气。如果能让Android系统源码在真实设备上跑跑看效果，那该多好。这不就是传说中的刷ROM吗？刷ROM这个话题是老罗以前一直避免谈的，因为觉得没有全面了解Android系统前就谈ROM是不完整的。写完了101篇文章后，老罗觉得第102篇文章该谈谈这个话题了，并且选择CM这个有代表性的ROM来谈，目标是加深大家对Android系统的了解。

老罗的新浪微博：http://weibo.com/shengyangluo，欢迎关注！

《Android系统源代码情景分析》一书正在进击的程序员网（http://0xcc0xcd.com）中连载，点击进入！

       说起刷ROM的动机，除了上面说的用来看Android系统源码在真实设备上的运行效果，还有很多值得说的。回想起PC时代，我们对我们自己拥有的设备（电脑），基本上能做的就是在上面重装系统。这个系统是厂商做好给我们的，里面有什么我们就用什么，不能随心所欲地定制。当然，如果你用的是Linux系统，你是可以随心所欲地对它进行定制的。不过可惜的是，我们的女神用的都是Windows系统。你和女神说你想要什么样的Linux系统，我给你定制一个，她会不知道你说的是什么——她需要的是一个不会中毒的又跑得快的Windows系统而已。现如今虽然很多女神用的是仍然是我们不能随心所欲定制的iOS系统，但是在移动设备上，iOS系统毕竟不能做到Windows在PC那样的一家独大——我们还有不少女神是用Android系统的。所以，如果你现在和女神说，我可以帮你刷一个专属的精简Android系统，里面没有一堆你不需要的预装软件，会让你的手机跑得很快，那女神得有多崇拜你啊。

       当然，刷ROM的动机不能只是为了让女神崇拜，作为一个程序猿，我们的首要任务是维护宇宙和平。怎么维护呢？至少程序有BUG不能不改吧。你不改的话，老板是不会放过你的。但是，碰到那些很棘手的BUG，怎么办呢？例如，你是一个Android应用开发者，调用一个API接口的时候，总是抛出一个异常，而这个异常不跟到API内部实现去看看实在是不知道什么原因造成的。这时候，如果你手头上有这个手机的系统源代码，找这个API内部实现的地方，加一两行调试代码，再编译回手机上去跑，是不是就很容易定位问题了呢？

        所以说，会刷ROM，不只是可以获得女神崇拜，还可以维护世界和平，作为一个Android开发者，你还有什么理由不去学习刷ROM呢？既然你决定学习刷ROM了，那你就得先搞清楚两个问题：1. 什么是刷ROM；2. 怎么学习刷ROM。

        在回答第一个问题之前，我们先来看看Android设备从硬件到系统的结构，如图1所示：



图1 Android系统架构

       最底层的是各种硬件设备，往上一层是Bootloader。Bootloader是什么概念呢？我们都知道，PC主板上有一小段程序叫做BIOS，主板加电时它是第一个跑起来的程序，负责初始化硬件，以及将OS启动起来。在嵌入式世界里（手机也是属于嵌入式设备），也有一小段类似BIOS的程序，不过它不叫BIOS，而是叫Bootloader。使用最广泛的Bootloader是一个叫uboot的程序，它支持非常多的体系结构。经过编译后，uboot会生成一个uboot.bin镜像，将这个镜像烧到设备上的一个特定分区去，就可以作为Bootloader使用了。

        Bootloader支持交互式启动，也就是我们可以让Bootloader初始化完成硬件之后，不是马上去启动OS，而是停留在当前状态，等待用户输入命令告诉它接下来该干什么。这种启动模块就称为Fastboot模式。对于Android设备来说，我们可以通过adb reboot bootloader命令来让它重新启动并且进入到Fastboot模式中去。

        在讨论Fastboot模式之前，我们先了解一下嵌入式设备的ROM结构（NAND flash之类的芯片）。通常，一个能够正常启动的嵌入式设备的ROM包含有以下四个分区：

        1. Bootloader分区，也就是存放uboot.bin的分区

        2. Bootloader用来保存环境变量的分区

        3. Kernel分区，也就是存放OS内核的分区

        4. Rootfs分区，也就是存入系统第一个进程init对应的程序的分区

        当设备处于Fastboot模式时，我们可以通过另外一个工具fastboot来让设备执行指定的命令。对搞机者来说，最常用的命令就是刷入各种镜像文件了，例如，往Kernel分区和Rootfs分区刷入指定的镜像。

        对于Android设备来说，当它处于Fastboot模式时，我们可以将一个包含有Kernel和Rootfs的Recovery.img镜像通过fastboot工具刷入到一个称为设备上一个称为Recovery的分区去。这个过程就是刷Recovery了，它也是属于刷ROM的一种。由于Recovery分区包含有Kernel和Rootfs，因此将Recovery.img刷入到设备后，我们就可以让设备正常地启动起来了。这种启动方式就称为Recovery模式。 对于Android设备来说，我们可以通过adb reboot recovery命令来让它进入到Recovery模式中去。

        当设备处于Recovery模式时，我们可以做些什么呢？答案是取决于刷入的Recovery.img所包含的Rootfs所包含的程序。更确切地说，是取决于Rootfs镜像里面的init程序都做了些什么事情。不过顾名思义，Recovery就是用来恢复系统的意思，也包含有更新系统的意思。这里所说的系统，是用户正常使用的系统，里面包含有Android运行时框架，使得我们可以在上面安装和使用各种APP。

       用户正常使用Android设备时的系统，主要是包含有两个分区：System分区和Boot分区。System分区包含有Android运行时框架、系统APP以及预装的第三方APP等，而Boot分区包含有Kernel和Rootfs。刷入到System分区和Boot分区的两个镜像称为system.img和boot.img，我们通常将它们打包和压缩为一个zip文件，例如update.zip，并且将它上传到Android设备上的sdcard上去。这样当我们进入到Recovery模式时，就可以在Recovery界面上用我们之前上传到sdcard的zip包来更新用户正常使用Android设备时所用的系统了。这个过程就是通常所说的刷ROM了。

       不知道大家看明白了没有？广义上的刷ROM，实际上包含更新Recovery和更新用户正常使用的系统两个意思；而狭义上的刷ROM，只是更新用户正常使用的那个系统。更新Recovery需要进入到Fastboot模式中，而更新用户正常使用的那个系统需要进入到Recovery模式中。Android设备在启动的过程中，在默认情况下，一旦Bootloader启动完成，就会直接启动用户正常使用的那个系统，而不会进入到Recovery模式，或者停留在Bootloader中，也就是停留在Fastboot模式中。只有通过特定的命令，例如adb reboot recovery和adb reboot bootloader，或者特定的按键，例如在设备启动过程中同时按住音量减小键和电源开关键，才能让设备进入到Recovery模式或者Fastboot模式中。

       因此，一个完整的刷ROM过程，包含以下两个步骤：

       1. 让设备进入到Fastboot模式，刷入一个recovery.img镜像

       2. 让设备进入到Recovery模式，刷入一个包含system.img镜像和boot.img镜像的zip包

       不过需要注意的是，system.img镜像和boot.img镜像不一定是只有在Recovery模式才能刷入，在Fastboot模式下也是可以刷入的，就像在Fastboot模式中刷入recovery.img镜像一样，只不过在Recovery模式下刷入它们更友好一些。说到这里，就不得不说另外一个概念，就是所谓的Bootloader锁。在锁定Bootloader的情况下，我们是无法刷入非官方的recovery.img、system.img和boot.img镜像的。这是跟厂商实现的Bootloader相关的，它们可以通过一定的算法（例如签名）来验证要刷入的镜像是否是官方发布的。在这种情况下，必须要对Bootloader进行解锁，我们才可以刷入非官方的镜像。

       好了，以上就回答了什么是刷ROM这个问题，接下来我们要回答的是如常学习刷ROM这个问题。

       前面我们提到了刷ROM的两个步骤，实际上我们还少了一个重要的步骤，那就是先要制作recovery.img、system.img和boot.img。有人可能会说，网上不是很多现成的刷机包吗？直接拿过来用不就是行了吗？但是别忘了前面我们所说的刷ROM动机：随心所欲地定制自己的系统。去拿别人制好的刷机包就失去了随心所欲定制的能力。那就只能自己去编译AOSP源码生成刷机包了。

       然而，从零开始从AOSP源码中编译出能在自己使用的手机上运行的系统，可不是一件容易的事情。不过，好在有很多现成的基于AOSP的第三方开源项目，可以编译出来在目前市场上大部分的手机上运行。其中，最著名的就是CyanogenMod了，简称CM。国内大部分的第三方Android系统，都是基于CM来开发的，包括MIUI和锤子。

       选择CM来讲解刷ROM的过程是本文的主题。不过单就刷ROM这个过程来说，CM官网上已经有很详细的过程，包括从CM源码编译出适用特定机型的刷机包，以及将编译出来的刷机包刷到手机里面去的过程。因此，本文不是单纯地讲解刷ROM过程，而是要结合原理来讲解刷ROM过程的关键步骤，来达到帮助大家更进一步地理解Android的目的。

        要真正做到理解CM ROM的刷机原理，除了要对Android系统本身有一定的认识之外，还熟练掌握Android的源码管理系统和编译系统。因此，在继续阅读下面的内容之前，希望可以先阅读前面Android源代码仓库及其管理工具Repo分析和Android编译系统简要介绍和学习计划这两个系列的文章。接下来我们就开始讲解CM ROM的刷机过程和原理。

        我们首先是要准备好环境以及手机。这是本次操作所用的环境以及手机：

        1. Ubuntu 13.04

        2. CM-10.1

        3. OPPO Find 5

        也就是说，我们将在Ubuntu 13.04上为OPPO Find 5制作CM-10.1的Recovery和ROM。

        不过先别急着制作自己的ROM。为了保证接下来的步骤可以顺利执行，我们首先尝试刷一下CM官方对应版本的Recovery和ROM到我们的OPPO Find 5手机上。如果一切正常，就说明我们使用CM的源码来制作的Recovery和ROM也是可以运行在OPPO Find 5上的。

        适合OPPO Find 5的CM官方Recovery下载地址：http://download2.clockworkmod.com/recoveries/recovery-clockwork-6.0.4.6-find5.img。假设我们下载好之后，保存在本地的路径为$CM/recovery-clockwork-6.0.4.6-find5.img。

        适合OPPO Find 5的CM官方10.1.3版本ROM下载地址：http://download.cyanogenmod.org/get/jenkins/42498/cm-10.1.3-find5.zip。假设我们下载好之后，保存在本地的路径为$CM/cm-10.1.3.find5.zip。

        注意，由于我们计划用CM-10.1源码来制作自己的ROM，所以我们在下载CM官方ROM，也要下载对应10.1版本的。

        在刷Recovery和ROM的过程中，我们需要借助于Android SDK里面的fastboot和adb工具，因此，为了方便执行这些命令，我们先将这些工具的目录加入到PATH环境变量去。假设我们下载的Android SDK保存在目录$ASDK中，那么打开一个终端，执行以下命令即可：

[plain] view plaincopy
$ export PATH=$ASDK/platform-tools:$PATH  
        先刷Recovery，步骤如下所示：
        1. 保持OPPO Find 5在正常开机状态，并且通USB连接到将有Ubuntu 13.04的电脑上。

        2. 还是在刚才打开的终端上，并且进入到保存recovery-clockwork-6.0.4.6-find5.img的目录$CM。

[plain] view plaincopy
$ cd $CM  
        3. 执行以下命令让OPPO Find 5重启，并且进入Fastboot模式。
[plain] view plaincopy
$ adb reboot bootloader  
        4. 可以看到OPPO Find 5停留在Fastboot界面上，执行以下命令确保fastboot工具能够连接到OPPO Find 5。
[plain] view plaincopy
$ fastboot devices  
       如果能够连接，那么上述命令将会输出一串标识OPPO Find 5的ID。
       5. 刷入我们刚才下载的Recovery。

[plain] view plaincopy
$ fastboot flash recovery recovery-clockwork-6.0.4.6-find5.img  
       6. 提示刷入成功后，执行以下命令正常重启手机。
[plain] view plaincopy
$ fastboot reboot  
       如果一切正常，手机将进入到原来的系统中。
       继续在上述打开的终端上，刷CM-10.1.3 ROM，步骤如下所示：

       1. 将下载好的cm-10.1.3.find5.zip上传至OPPO Find 5的sdcard上

[plain] view plaincopy
$ adb push cm-10.1.3.find5.zip /sdcard/cm-10.1.3.find5.zip  
       2. 执行以下命令让OPPO Find 5重启，并且进入Recovery模式。
[plain] view plaincopy
$ adb reboot recovery  
       进入到Recovery模式后，我们将看到显示的Recovery版本号为6.0.4.6，这表明我们现在进入的就是刚才我们刷入的Recovery。
       3. 在刷入新的ROM前，我们先备份一下当前的ROM，以防万一刷机失败，可以进行恢复。在Recovery界面中，通过音量增大/减小键，选中“backup and restore”选项，按下电源键，进入下一个界面，同样是通过音量增大/减小键，选中“backup”，按下电源键，就可以对当前系统进行备份了。

       4. 备份完成之后，我们还要清除手机上的数据，恢复至出厂设置。回到Recovery界面中，通过音量增大/减小键，选中"wipe data/factory reset"，按下电源键，确认后即可进行清除数据，并且恢复至出厂设置。

       5. 清除数据完成之后，再回到Recovery界面上，通过音量增大/减小键，选中“install zip”选项，按下电源键，进入下一个界面，同样是通过音量增大/减小键，选中“choose zip from sdcard”，按下电源键，找到前面我们上传至sdcard的cm-10.1.3.find5.zip，确认之后就可以进行刷机了。

       6. 刷机完成后，再回到Recovery界面上，通过音量增大/减小键，选中“reboot system now”选项，按下电源键，正常启动系统。

       如果一切正常，手机将进入到刚才刷入的CM-10.1.3系统中。

       现在我们就可以确定OPPO Find 5可以正常运行CM-10.1.3的系统了。接下来激动人心的时刻就要开始了，我们将要自己下载和编译CM-10.1源码，并且将编译出来的Recovery和ROM刷入到OPPO Find 5去。同时，在接下来的步骤中，我们会将相关的原理讲清楚，以便我们可以更好地理解Android系统的结构，这也是本文的重点之一。以下假设我们将CM-10.1源码保存在目录$CMSOURCE中，并且已经按照Android官网文档的要求初始化好Android的源码编译环境，即在我们的Ubuntu机器上安装了要求的软件，详情请参考：http://source.android.com/source/initializing.html。

        1. 进入到$CMSOURCE目录中。

[plain] view plaincopy
$ cd $CMSOURCE  
        2. 将当前目录初始为CM-10.1分支源码的Git仓库。
[plain] view plaincopy
$ repo init -u git://github.com/CyanogenMod/android.git -b cm-10.1  
        3. 下载CM-10.1分支源码。
[plain] view plaincopy
$ repo sync  
        以上两步都是关于Android源码仓库的知识，可以参考Android源代码仓库及其管理工具Repo分析一文，这里不再详述。
        4. 进入到$CMSOURCE目录下的vendor/cm子目录中，并且执行里面的get-prebuilts脚本，用来获得一些预编译的APP。

[plain] view plaincopy
$ ./get-prebuilts  
        打开$CMSOURCE/vendor/cm/get-prebuilts文件，它的内容如下所示：
[plain] view plaincopy
BASEDIR=`dirname $0`  
  
mkdir -p $BASEDIR/proprietary  
  
# Get Android Terminal Emulator (we use a prebuilt so it can update from the Market)  
curl -L -o $BASEDIR/proprietary/Term.apk -O -L http://jackpal.github.com/Android-Terminal-Emulator/downloads/Term.apk  
unzip -o -d $BASEDIR/proprietary $BASEDIR/proprietary/Term.apk lib/*  
        我们可以发现，实际上这里只是去下载一个叫做Android Terminal Emulator的APP，地址是http://jackpal.github.com/Android-Terminal-Emulator/downloads/Term.apk。这个APP最终会包含在我们自己编译出来的ROM。它用来Android手机上模拟出一个终端来，然后我们就可以像在Linux主机上一样执行一些常用的Linux命令。是不是很酷呢？原来Android手机不单止可以运行我们常见的APP，还可以运运我们常用的Linux命令。关于这个Android Terminal Emulator的安装和介绍，参可以这里：https://github.com/jackpal/Android-Terminal-Emulator。此外，这个Android Terminal Emulator还可以配合另外一个封装了busybox的kbox工具，用来在Android手机上获得更多的Linux常用命令，kbox的安装和介绍，可以参考这里：http://kevinboone.net/kbox2_install.html。
        5. 回到$CMSOURCE目录中，将build子目录下的envsetup.sh脚本加载到当前终端来。

[plain] view plaincopy
$ source build/envsetup.sh  
        参考Android编译系统环境初始化过程分析一文，envsetup.sh脚本加载到当前终端后，我们就可以获得一系列与Android编译系统相关的命令，例如lunch/m/mm/mmm，以及下一步要执行的breakfast命令。
        6. 为OPPO Find 5下载相关的源码。

[plain] view plaincopy
$ breakfast find5  
        在Android编译系统简要介绍和学习计划这个系列的文章中，我们提到，在编译Android的官方源码之前，我们需要执行一个lunch命令来为我们的目标设备初始化编译环境。这个lunch命令是由Android官方源码的envsetup.sh脚本提供的。CM修改envsetup.sh脚本，额外提供了一个breakfast命令，用来从网上寻找指定的设备相关的源码，以便我们可以为该设备编译出能运行的ROM来。
        打开envsetup.sh文件，查看breakfast的实现：

[plain] view plaincopy
function breakfast()  
{  
    target=$1  
    CM_DEVICES_ONLY="true"  
    unset LUNCH_MENU_CHOICES  
    add_lunch_combo full-eng  
    for f in `/bin/ls vendor/cm/vendorsetup.sh 2> /dev/null`  
        do  
            echo "including $f"  
            . $f  
        done  
    unset f  
  
    if [ $# -eq 0 ]; then  
        # No arguments, so let's have the full menu  
        lunch  
    else  
        echo "z$target" | grep -q "-"  
        if [ $? -eq 0 ]; then  
            # A buildtype was specified, assume a full device name  
            lunch $target  
        else  
            # This is probably just the CM model name  
            lunch cm_$target-userdebug  
        fi  
    fi  
    return $?  
}  
        函数breakfast主要是做了以下两件事情。

        第一件事情是检查vendor/cm目录下是否存在一个vendorsetup.sh文件。如果存在的话，就将它加载到当前终端来。注意，这里是通过ls命令来检查文件endor/cm/vendorsetup.sh是否存在的。如果不存在的话，标准输出就为空，而错误信息会重定向至/dev/null。如果存在的话，字符串“endor/cm/vendorsetup.sh”就会输出到标准输出来，也就是变量f的值会等于“endor/cm/vendorsetup.sh”。

        接下来我们就看看文件endor/cm/vendorsetup.sh的内容：

[plain] view plaincopy
for combo in $(curl -s https://raw.github.com/CyanogenMod/hudson/master/cm-build-targets | sed -e 's/#.*$//' | grep cm-10.1 | awk {'print $1'})  
do  
    add_lunch_combo $combo  
done  
        它所做的工作就是将https://raw.github.com/CyanogenMod/hudson/master/cm-build-targets的内容下载回来，并且去掉其中的空行，最后将含有"cm-10.1"的行的第1列取出来，并且通过add_lunch_combo命令将其加入到Android编译系统的lunch菜单去。
        从https://raw.github.com/CyanogenMod/hudson/master/cm-build-targets下载回来的是官方CM所支持的机型列表，格式为cm_<product>-<variant> <version>，以下列出的是部分内容：

[plain] view plaincopy
# CM build target list  
# <lunchcombo> <branch> [period: "D"aily, "W"eekly or "M"onthly]  
# Absence of a period indicates Daily (the default)  
  
cm_a700-userdebug cm-11.0  
cm_acclaim-userdebug cm-11.0  
cm_amami-userdebug cm-11.0  
cm_anzu-userdebug jellybean M  
cm_apexqtmo-userdebug cm-11.0  
cm_aries-userdebug cm-11.0  
cm_captivatemtd-userdebug cm-11.0  
......  
        由此可见，执行脚本endor/cm/vendorsetup.sh之后，cm-10.1所支持的机型就会增加到lunch菜单中去。
        回到函数breakfast中，它所做的第二件事情是检查执行函数是否带有参数，即变量target的值是否等于空。如果变量target的值不等于空，并且它的值是<product>-<variant>的形式，那么就直接以它为参数，调用lunch函数。否则的话，就以cm_$target-userdebug为参数，调用lunch函数。

        在这一步中，我们调用breakfast函数时，传进来的参数为find5，不是<product>-<variant>的形式，因此，函数breakfast最后会以cm_find5-userdebug为参数，调用lunch函数。

        函数lunch的实现我们在前面一篇文章Android编译系统环境初始化过程分析已经分析过了，不过当时分析的是AOSP官方版本的实现，CM对其进行了一些修改，增加了一些CM自有的逻辑，下面我们就看看这些修改：

[plain] view plaincopy
function lunch()  
{  
    ......  
  
    local product=$(echo -n $selection | sed -e "s/-.*$//")  
    check_product $product  
    if [ $? -ne 0 ]  
    then  
        # if we can't find a product, try to grab it off the CM github  
        T=$(gettop)  
        pushd $T > /dev/null  
        build/tools/roomservice.py $product  
        popd > /dev/null  
        check_product $product  
    else  
        build/tools/roomservice.py $product true  
    fi  
      
    ......  
}  
       这里的变量selection的值就等于我们传进来的参数"cm_find5-userdebug"，通过sed命令将"cm_find5"提取出来，并且赋值给变量product。接下来调用check_product函数来检查当前的CM源码中是否支持find5这个设备。
       如果不支持的话，那么它的返回值就不等于0，即#?不等于0，那么接下来就会通过build/tools/roomservice.py到CM源码服务器去检查是否支持find5这个设备。如果CM源码服务器支持find5这个设备的话，那么build/tools/roomservice.py就会将与find5相关的源码下载回来。这时候我们就会发现本地CM源码目录中多了一个device/oppo/find5目录。里面存放的都是编译find5的ROM时所要用的文件。

       另一方面，如果当前的CM源码中已经支持find5这个设备，那么函数lunch也会调用build/tools/roomservice.py去CM源码服务器检查当前CM源码目录中find5设备依赖的其它源码是否有更新，或者是否有新的依赖。如果有的话，就将这些依赖更新下载回来。

       脚本build/tools/roomservice.py的详细内容这里就不分析了，下面主要是解释一下与Android的源码仓库管理工具Repo相关的逻辑。关于Android的源码仓库管理工具Repo的详细分析，可以参考Android源代码仓库及其管理工具Repo分析一文。

       CM源码服务器放在github上，地址为http://github.com/CyanogenMod，上面保存的是CM修改过的AOSP工程、CM支持的设备相关源码工程（下载回来放在device/<manufacturer>/<device>目录中），以及CM支持的设备对应的内核源码工程（下载回来放在kernel/<manufacturer>/<device>目录中）。

       脚本build/tools/roomservice.py会根据传进来的第一个参数，到CM源码服务上检查是否存在相应的工程。在我们这个场景中，传给build/tools/roomservice.py的第一个参数为cm_find5。这时候前面的cm_会被去掉，然后到CM源码服务上检查是否存在一个android_device_<manufacturer>_find5的工程。如果存在的话，那么就会将它下载回来，保存在device/<manufacturer>/find5目录中。这里的<manufacturer>对应的就是oppo了。

       下载回来的设备相关源码实际上是作为是一个Git仓库来管理的，因此，脚本build/tools/roomservice.py还需要将该Git仓库纳入到Repo仓库去管理，以便以后执行repo sync命令时，可以同时对这些设备相关的源码进行更新。

        从Android源代码仓库及其管理工具Repo分析一文可以知道，Repo仓库保存在.repo目录中，而它所管理的Git仓库由.repo/manifest.xml文件描述。文件.repo/manifest.xml实际上只是一个符号链接，它链接至.repo/manifests/default.xml文件。目录.repo/manifests实际上也是一个Git仓库，用来描述当前的CM源码目录都是由哪些工程构成的，并且这些工程是来自于哪些Git远程仓库的。

       如果按照标准的Repo仓库管理方法，从CM源码服务器上下载回来设备相关源码之后，应该往.repo/manifests/default.xml文件增加相应的描述，以后repo工具可以对这些设备相关的源码进行管理。但是，由于Repo仓库是由官方维护的，当我们在本地往.repo/manifests/default.xml增加了新的内容之后，下次执行repo sync命令时，.repo/manifests/default.xml的内容又会被恢复至修改前的样子，因此，修改.repo/manifests/default.xml文件是不适合的。CM采用另外一个办法，那就是在.repo目录下另外创建一个local_manifests目录，在里面可以随意增加任意命名的xml文件，只要这些xml文件的规范与.repo/manifests/default.xml文件的规范一致即可。执行repo sync命令时，它就会同时从.repo/manifests/default.xml和.repo/local_manifests目录下的xml文件中读取当前都有哪些源码工程需要更新。

       实际上，在.repo/local_manifests目录下的xml文件，除了可以描述新增的工程之外，还可以描述要删除的工程。例如，如果我们不想将某一个系统功能或者系统APP编译到我们自己制作的ROM去，那么就可以在.repo/local_manifests目录下增加一个xml文件，里面描述我们需要删除对应的工程。这样，当我们从服务器下载回来相应的工程之后，它们就会在本地中被删除。这样就做到了很好的定制化编译，而且又不会与官方的源码结构产生冲突。关于CM的Local Manifests机制，可以参考官方文档：http://wiki.cyanogenmod.org/w/Doc:_Using_manifests。

       脚本build/tools/roomservice.py将下载回来的设备相关源码纳入到Repo仓库管理的办法就是在.repo/local_manifests目录下创建一个roomservice.xml文件。例如，当我们从CM源码服务器下载回来find5相关的设备源码之后，就可以看到在roomservice.xml文件中看到相应的一行内容：

[html] view plaincopy
<?xml version="1.0" encoding="UTF-8"?>  
<manifest>  
  ......  
  <project name="CyanogenMod/android_device_oppo_find5" path="device/oppo/find5" remote="github" />  
  ......  
</manifest>  
       这表明本地的device/oppo/find5目录是来自于远程仓库github的，并且相对路径为CyanogenMod/android_device_oppo_find5。
       好了，现在我们终于将OPPO Find 5相关的设备源码下载回来了，但是在编译之前。需要从OPPO Find 5上提取一些设备相关的私有文件。

       7. 保持OPPO Find 5开机状态，并且通过USB连接到Ubuntu 13.04上，进行到$CMSOURCE/device/oppo/find5目录中,执行以下命令提取设备私有文件。

[plain] view plaincopy
$ ./extract-files.sh  
       脚本extract-files.sh的内容如下所示：
[plain] view plaincopy
#!/bin/sh  
  
VENDOR=oppo  
DEVICE=find5  
  
BASE=../../../vendor/$VENDOR/$DEVICE/proprietary  
rm -rf $BASE/*  
  
for FILE in `cat proprietary-blobs.txt | grep -v ^# | grep -v ^$ | sed -e 's#^/system/##g'`; do  
    DIR=`dirname $FILE`  
    if [ ! -d $BASE/$DIR ]; then  
        mkdir -p $BASE/$DIR  
    fi  
    adb pull /system/$FILE $BASE/$FILE  
done  
  
./setup-makefiles.sh  
       首先是创建一个vendor/oppo/find5/proprietary目录，接着是读取文件proprietary-blobs.txt中的每一行，并且将每一行所描述的文件从设备上的/system目录中获取出来，保存在vendor/oppo/find5/proprietary对应的子目录下面，最后再执行另外一个脚本setup-makefiles.sh。

       文件device/oppo/find5/proprietary-blobs.txt部分的内容如下所示：

[plain] view plaincopy
/bin/btnvtool  
/bin/ds_fmc_appd  
/bin/efsks  
/bin/hci_qcomm_init  
/bin/ks  
/bin/mm-qcamera-daemon  
/bin/mpdecision  
/bin/netmgrd  
/bin/nv_tee  
/bin/qcks  
/bin/qmuxd  
......  
       这里列出的文件路径都是相对于设备上的/system目录的，并且都是设备特定的、不公开源码的，因此，我们需要从设备上获取出来。
       再来看脚本setup-makefiles.sh的内容：

[plain] view plaincopy
#!/bin/sh  
  
VENDOR=oppo  
DEVICE=find5  
OUTDIR=vendor/$VENDOR/$DEVICE  
MAKEFILE=../../../$OUTDIR/$DEVICE-vendor-blobs.mk  
  
(cat << EOF) > $MAKEFILE  
# Copyright (C) 2013 The CyanogenMod Project  
#  
# Licensed under the Apache License, Version 2.0 (the "License");  
# you may not use this file except in compliance with the License.  
# You may obtain a copy of the License at  
#  
#      http://www.apache.org/licenses/LICENSE-2.0  
#  
# Unless required by applicable law or agreed to in writing, software  
# distributed under the License is distributed on an "AS IS" BASIS,  
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
# See the License for the specific language governing permissions and  
# limitations under the License.  
  
# This file is generated by device/$VENDOR/$DEVICE/setup-makefiles.sh  
  
PRODUCT_COPY_FILES += \\  
EOF  
  
LINEEND=" \\"  
COUNT=`cat proprietary-blobs.txt | grep -v ^# | grep -v ^$ | wc -l | awk {'print $1'}`  
for FILE in `cat proprietary-blobs.txt | grep -v ^# | grep -v ^$ | sed -e 's#^/system##g' -e 's#^/##g'`; do  
    COUNT=`expr $COUNT - 1`  
    if [ $COUNT = "0" ]; then  
        LINEEND=""  
    fi  
    echo "    $OUTDIR/proprietary/$FILE:system/$FILE$LINEEND" >> $MAKEFILE  
done  
  
(cat << EOF) > ../../../$OUTDIR/$DEVICE-vendor.mk  
# Copyright (C) 2013 The CyanogenMod Project  
#  
# Licensed under the Apache License, Version 2.0 (the "License");  
# you may not use this file except in compliance with the License.  
# You may obtain a copy of the License at  
#  
#      http://www.apache.org/licenses/LICENSE-2.0  
#  
# Unless required by applicable law or agreed to in writing, software  
# distributed under the License is distributed on an "AS IS" BASIS,  
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
# See the License for the specific language governing permissions and  
# limitations under the License.  
  
# This file is generated by device/$VENDOR/$DEVICE/setup-makefiles.sh  
  
# Pick up overlay for features that depend on non-open-source files  
DEVICE_PACKAGE_OVERLAYS := vendor/$VENDOR/$DEVICE/overlay  
  
\$(call inherit-product, vendor/$VENDOR/$DEVICE/$DEVICE-vendor-blobs.mk)  
EOF  
  
(cat << EOF) > ../../../$OUTDIR/BoardConfigVendor.mk  
# Copyright (C) 2013 The CyanogenMod Project  
#  
# Licensed under the Apache License, Version 2.0 (the "License");  
# you may not use this file except in compliance with the License.  
# You may obtain a copy of the License at  
#  
#      http://www.apache.org/licenses/LICENSE-2.0  
#  
# Unless required by applicable law or agreed to in writing, software  
# distributed under the License is distributed on an "AS IS" BASIS,  
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
# See the License for the specific language governing permissions and  
# limitations under the License.  
  
# This file is generated by device/$VENDOR/$DEVICE/setup-makefiles.sh  
  
USE_CAMERA_STUB := false  
EOF  
       这个脚本主要就是用来在vendor/oppo/find5目录下生成两个文件：find5-vendor-blobs.mk和BoardConfigVendor.mk文件。这两个文件都是接下来为OPPO Find 5编译ROM时要用到的。
       生成的find5-vendor-blobs.mk的部分内容如下所示：

[plain] view plaincopy
PRODUCT_COPY_FILES += \  
    vendor/oppo/find5/proprietary/bin/btnvtool:system/bin/btnvtool \  
    vendor/oppo/find5/proprietary/bin/ds_fmc_appd:system/bin/ds_fmc_appd \  
    vendor/oppo/find5/proprietary/bin/efsks:system/bin/efsks \  
    vendor/oppo/find5/proprietary/bin/hci_qcomm_init:system/bin/hci_qcomm_init \  
    vendor/oppo/find5/proprietary/bin/ks:system/bin/ks \  
......  
       实际上就是通过PRODUCT_COPY_FILES变量告诉编译系统，要将刚才从设备上获取回来的文件打包到编译出来的ROM的system分区里面去。
       生成的文件BoardConfigVendor.mk只有1行，如下所示：

[plain] view plaincopy
USE_CAMERA_STUB := false  
       在编译摄像头相关的库文件时，就会到这里定义的USE_CAMERA_STUB变量。
       到目前为止，我们就分别从CM源码服务器和目标设备上获取到了编译OPPO Find 5的ROM所需要的设备相关的文件了，接下来就可以开始编译CM源码了。

       8. 回到$CMSOUCE目录中，为OPPO Find 5编译ROM。

[plain] view plaincopy
$ brunch find5  
       命令brunch也是由build/envsetup.sh脚本提供的，它的实现如下所示：
[plain] view plaincopy
function brunch()  
{  
    breakfast $*  
    if [ $? -eq 0 ]; then  
        mka bacon  
    else  
        echo "No such item in brunch menu. Try 'breakfast'"  
        return 1  
    fi  
    return $?  
}  
       函数brunch做了两件事情：执行breakfast命令和执行mka bacon命令。
       前面我们不是已经执行过breakfast命令了吗？这里为什么又要再执行一次呢？从前面的分析可以知道，函数breakfast在执行的过程中，会调用函数lunch，而函数lunch又会调用函数check_product来检查目标设备是否存在。因为在前一步中，我们已经将目标设备相关的源码下载回来了，因此这时候目标设备是肯定存在的。当目标设备存在的时候，函数lunch会通过build/tools/roomservice.py脚本检查目标设备相关的源码是否依赖有其它工程，并且这些工程是否已经下载回来了。如果有依赖的工程，并且这些工程还没有下载回来，那么就需要将它们下载回来。

       当目标设备存在的时候，函数lunch执行build/tools/roomservice.py脚本的形式为：

[plain] view plaincopy
build/tools/roomservice.py $product true  
       传递给build/tools/roomservice.py第二件参数为true，表示要处理的是目标设备$product依赖的工程。
       脚本build/tools/roomservice.py是如何知道目标设备有没有依赖的工程的呢？原来，在下载回来的设备源码中，有一个cm.dependencies文件，里面描述了自己所依赖的工程。例如，device/oppo/find5/cm.dependencies的内容如下所示：

[plain] view plaincopy
[  
 {  
   "repository": "android_kernel_oppo_find5",  
   "target_path": "kernel/oppo/find5",  
   "branch": "cm-10.1"  
 }  
]  
       上面描述的是OPPO Find 5所使用的内核源码，它来自于CM源码服务器上的android_kernel_oppo_find5仓库的cm-10.1分支，下载回来后保存在kernel/oppo/find5目录中。这意味着我们通过CM源码编译出来的ROM所使用的内核也是由我们自己编译出来的。
       为了以后执行repo sync命令同步本地源码时，也可以将设备源码依赖的工程也同时同步回来，我们需要将这些依赖工程也纳入到Repo仓库中去，因此，当再次执行过breakfast使命之后。我们就可以在.repo/local_manifests/roomservice.xml文件中发现以下两行内容：

[plain] view plaincopy
<?xml version="1.0" encoding="UTF-8"?>  
<manifest>  
  ......  
  <project name="CyanogenMod/android_device_oppo_find5" path="device/oppo/find5" remote="github" />  
  <project name="CyanogenMod/android_kernel_oppo_find5" path="kernel/oppo/find5" remote="github" revision="cm-10.1" />  
  ......  
</manifest>  
      回到函数brunch中，它接下来执行的命令mka也是由build/envsetup.sh脚本提供的，如下所示：
[plain] view plaincopy
function mka() {  
    case `uname -s` in  
        Darwin)  
            make -j `sysctl hw.ncpu|cut -d" " -f2` "$@"  
            ;;  
        *)  
            schedtool -B -n 1 -e ionice -n 1 make -j$(cat /proc/cpuinfo | grep "^processor" | wc -l) "$@"  
            ;;  
    esac  
}  
       它实际上是通过一个叫做schedtool的工具来调用make工具对源码进行编译。我们知道，编码Android源码是一个漫长的过程，而现在的机器都是多核的，为了加快这个编译过程，需要将机器的所有核以都充分利用起来。工具schedtool所做的事情就是充分地利机器的多核特性来执行make命令，使得我们可以尽快结束编译过程。
       关于Android源码的编译详细过程，可以参考Android编译系统简要介绍和学习计划这个系列的文章，这里只进行简要的说明。

       从Android编译系统简要介绍和学习计划这个系列一文可以知道，Android的编译系统是由很多的mk文件组成的，每一个mk文件都是一个Makefile脚本片段。在编译开始之前，这些mk文件会组合在一起，形成一个很大的Makefile文件，然后再根据这个很大的Makefile文件的指令对源码进行编译。

       由这些mk文件组成的Makefile文件内容可以抽象为四个层次，如图2所示：



图2 Android编译系统层次

       最下面一层描述的设备CPU的体系架构（Architecture），Android设备支持arm、x86和mips三种CPU体系架构。再往上一层描述的是设备所使用的芯片（Board），例如用的是高通的芯片，还是三星的芯片，等等，与这些芯片相关的源文件存放在hardware目录下。接下来再往上的一层是设备（Device），描述的是具体的硬件设备。最上面的一层是产品（Product），描述的是在硬件设备上运行的软件模块。

       在这一步中，我们通过brunch命令编译CM源码时，指定的唯一参数是find5，那么Android编译系统是如何根据这个参数来找包含上述四个层次的mk文件为OPPO Find 5编译出能正常运行的ROM的呢？

       在我们执行breakfast或者brunch命令的过程中，会调用另外一个函数check_product。根据Android编译系统环境初始化过程分析一文，函数check_product会通过另外一个函数get_build_var加载build/core/config.mk文件。文件build/core/config.mk又会继续加载另外一个文件build/core/envsetup.mk。最后，文件build/core/envsetup.mk又会加载另外一个文件build/core/product_config.mk。

       在build/core/product_config.mk文件的加载过程中，有以下的一段逻辑：

[plain] view plaincopy
ifneq ($(strip $(TARGET_BUILD_APPS)),)  
# An unbundled app build needs only the core product makefiles.  
all_product_configs := $(call get-product-makefiles,\  
    $(SRC_TARGET_DIR)/product/AndroidProducts.mk)  
else  
  ifneq ($(CM_BUILD),)  
    all_product_configs := $(shell ls device/*/$(CM_BUILD)/cm.mk)  
  else  
    # Read in all of the product definitions specified by the AndroidProducts.mk  
    # files in the tree.  
    all_product_configs := $(get-all-product-makefiles)  
  endif # CM_BUILD  
endif  
       当我们编译的是整个Android源码时，变量TARGET_BUILD_APPS的值等于空。这时候就会判断是否设置了一个名称为CM_BUILD的环境变量。如果设置了的话，那么接下来就会加载device/*/$(CM_BUILD)目录下的cm.mk文件来获得目标产品配置文件。否则，首先会通过调用另外一个函数get-all-product-makefiles来获得/device/*/*目录下的所有名称为AndroidProducts.mk的文件，接着再在这些AndroidProducts.mk文件中定义的PRODUCT_MAKEFILES变量来获得目标产品配置文件。
       环境变量CM_BUILD的值是在函数check_product中设置的，并且只有在CM源码中编译时才会设置。在AOSP源码编译时，是不会设置环境变量CM_BUILD的。CM版本的check_product函数实现如下所示：

[plain] view plaincopy
function check_product()  
{  
    T=$(gettop)  
    if [ ! "$T" ]; then  
        echo "Couldn't locate the top of the tree.  Try setting TOP." >&2  
        return  
    fi  
  
    if (echo -n $1 | grep -q -e "^cm_") ; then  
       CM_BUILD=$(echo -n $1 | sed -e 's/^cm_//g')  
       if [ `uname` == "Darwin" ]; then  
           export BUILD_NUMBER=$((date +%s%N ; echo $CM_BUILD; hostname) | openssl sha1 | cut -c1-10)  
       else  
           export BUILD_NUMBER=$((date +%s%N ; echo $CM_BUILD; hostname) | sha1sum | cut -c1-10)  
       fi  
    else  
       CM_BUILD=  
    fi  
    export CM_BUILD  
  
    CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \  
        TARGET_PRODUCT=$1 \  
        TARGET_BUILD_VARIANT= \  
        TARGET_BUILD_TYPE= \  
        TARGET_BUILD_APPS= \  
        get_build_var TARGET_DEVICE > /dev/null  
    # hide successful answers, but allow the errors to show  
}  
        从这里就可以看出，环境变量CM_BUILD的值实际上就是目标设备的名称。例如，前面我们执行breakfast命令时，通过函数lunch调用check_product函数时，传进来的参数为为cm_find5，函数check_product会将find5提取出来，并且赋值给环境变量CM_BUILD。这样在加载build/core/product_config.mk文件时，找到的产品配置文件就为device/*/find5/cm.mk文件。在device目录中，只有oppo子目录包含有find5这个目录，因此最终加载的实际上是device/oppo/find5/cm.mk文件。
        无论是通过环境变量CM_BUILD来直接获得的目标产品配置文件，还是通过AndroidProducts.mk文件间接获得的目标产品配置文件，获得的目标产品配置文件都会直接或者间接地通过变量PRODUCT_COPY_FILES和PRODUCT_PACKAGES来设备要包含的软件模块。

        以device/oppo/find5/cm.mk为例，它的部分内容如下所示：

[plain] view plaincopy
......  
# Inherit device configuration  
$(call inherit-product, device/oppo/find5/full_find5.mk)  
  
## Device identifier. This must come after all inclusions  
PRODUCT_DEVICE := find5  
PRODUCT_NAME := cm_find5  
PRODUCT_BRAND := Oppo  
PRODUCT_MODEL := Find 5  
PRODUCT_MANUFACTURER := Oppo  
......  
        除定了一些设备相关的变量之外，它还会加载另外一个文件device/oppo/find5/full_find5.mk，后者的部分内容如下所示：
[plain] view plaincopy
# Inherit from hardware-specific part of the product configuration  
$(call inherit-product, device/oppo/find5/device.mk)  
$(call inherit-product-if-exists, vendor/oppo/find5/find5-vendor.mk)  
       文件device/oppo/find5/full_find5.mk又会继续加载另外两个文件device/oppo/find5/device.mk和vendor/oppo/find5/find5-vendor.mk。
       在文件device/oppo/find5/device.mk中，我们就可以看到PRODUCT_COPY_FILES和PRODUCT_PACKAGES的定义：

[plain] view plaincopy
PRODUCT_PACKAGES := \  
    lights.msm8960  
  
PRODUCT_PACKAGES += \  
    charger_res_images \  
    charger  
  
# Vold and Storage  
PRODUCT_COPY_FILES += \  
        device/oppo/find5/configs/vold.fstab:system/etc/vold.fstab  
  
# Live Wallpapers  
PRODUCT_PACKAGES += \  
        LiveWallpapers \  
        LiveWallpapersPicker \  
        VisualizationWallpapers \  
        librs_jni  
......  
       而文件vendor/oppo/find5/find5-vendor.mk会加载另外一个文件vendor/oppo/find5/find5-vendor-blobs.mk，如下所示：
[plain] view plaincopy
......  
$(call inherit-product, vendor/oppo/find5/find5-vendor-blobs.mk)  
......  
        回忆前面的第7步，文件文件vendor/oppo/find5/find5-vendor-blobs.mk是我们执行extract-files.sh脚本的时候生成的，里面通过变量PRODUCT_COPY_FILES告诉编译系统将从设备上获得的私有文件打包到要制作的ROM去。
        以上就是Product级别的配置信息的获取过程，接下来我们再看Device、Board和Architecture级别的配置信息的获取过程。

        函数check_product会通过另外一个函数get_build_var来加载build/core/config.mk文件的过程中，会在目标产品对应的设备目录中找到一个名称为BoardConfig.mk文件，如下所示：

[plain] view plaincopy
......  
board_config_mk := \  
    $(strip $(wildcard \  
        $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \  
        device/*/$(TARGET_DEVICE)/BoardConfig.mk \  
        vendor/*/$(TARGET_DEVICE)/BoardConfig.mk \  
    ))  
......  
        上述Makefile脚本片段会在build/target/board、device/*、vendor/*目录中寻找一个名称为$(TARGET_DEVICE)的子目录，并且在找到的子目录里面加载一个名称为BoardConfig.mk文件，来获得Device、Board和Architecture级别的配置信息。
        变量TARGET_DEVICE指向的便是目标设备的名称。在我们这个场景中，它的值就等于find5，因此，最终获得的Device、Board和Architecture级别的配置信息就是来自于device/oppo/find5/BoardConfig.mk文件，它的部分内容如下所示：

[plain] view plaincopy
TARGET_CPU_ABI := armeabi-v7a  
TARGET_CPU_ABI2 := armeabi  
......  
TARGET_ARCH := arm  
......  
  
# Bluetooth  
BOARD_HAVE_BLUETOOTH := true  
BOARD_HAVE_BLUETOOTH_QCOM := true  
BLUETOOTH_HCI_USE_MCT := true  
......  
  
TARGET_BOARD_PLATFORM := msm8960  
......  
  
# Wifi  
BOARD_HAS_QCOM_WLAN              := true  
BOARD_WLAN_DEVICE                := qcwcn  
......  
  
# Display  
TARGET_QCOM_DISPLAY_VARIANT := caf  
USE_OPENGL_RENDERER := true  
......  
  
# GPS  
BOARD_HAVE_NEW_QC_GPS := true  
......  
  
# Camera  
COMMON_GLOBAL_CFLAGS += -DDISABLE_HW_ID_MATCH_CHECK -DQCOM_BSP_CAMERA_ABI_HACK -DNEW_ION_API  
......  
  
# Audio  
BOARD_USES_ALSA_AUDIO:= true  
TARGET_QCOM_AUDIO_VARIANT := caf  
TARGET_USES_QCOM_MM_AUDIO := true  
TARGET_USES_QCOM_COMPRESSED_AUDIO := true  
BOARD_AUDIO_CAF_LEGACY_INPUT_BUFFERSIZE := true  
......  
        从这里就可以看到各种Device、Board和Architecture级别的配置信息。例如，CPU体系架构由TARGET_ARCH、TARGET_CPU_ABI和TARGET_CPU_ABI2来描述。芯片类型由TARGET_BOARD_PLATFORM来描述，而设备信息的描述则包括Bluetooth、Wifi、Display、GPS、Camera和Audio等。
        在BoardConfig.mk文件中配置的编译信息是在什么时候用到的呢？以下我们就以TARGET_BOARD_PLATFORM为例，说明这些配置信息在编译的过程中是如何使用的。在Android源码中，hardware目录包含各种芯片相关的模块源码。在这些模块的编译脚本中，就会根据TARGET_BOARD_PLATFORM的值来为指定的芯片编译出正确的模块来。

        例如，假设我们使用的是高通芯片，在它的Camera HAL2模块源码目录hardware/qcom/camera/QCamera/HAL2/core中定义的Android.mk文件有如下的内容：

[plain] view plaincopy
......  
LOCAL_CFLAGS += -DCAMERA_ION_HEAP_ID=ION_CP_MM_HEAP_ID # 8660=SMI, Rest=EBI  
LOCAL_CFLAGS += -DCAMERA_ZSL_ION_HEAP_ID=ION_CP_MM_HEAP_ID  
  
LOCAL_CFLAGS+= -DHW_ENCODE  
LOCAL_CFLAGS+= -DUSE_NEON_CONVERSION  
  
ifeq ($(TARGET_BOARD_PLATFORM),msm8960)  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_HEAP_ID=GRALLOC_USAGE_PRIVATE_MM_HEAP  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_FALLBACK_HEAP_ID=GRALLOC_USAGE_PRIVATE_IOMMU_HEAP  
        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID  
        LOCAL_CFLAGS += -DCAMERA_ZSL_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0  
else ifeq ($(TARGET_BOARD_PLATFORM),msm8660)  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_HEAP_ID=GRALLOC_USAGE_PRIVATE_CAMERA_HEAP  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_FALLBACK_HEAP_ID=GRALLOC_USAGE_PRIVATE_CAMERA_HEAP # Don't Care  
        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_CAMERA_HEAP_ID # EBI  
        LOCAL_CFLAGS += -DCAMERA_ZSL_ION_FALLBACK_HEAP_ID=ION_CAMERA_HEAP_ID  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0  
else  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_HEAP_ID=GRALLOC_USAGE_PRIVATE_ADSP_HEAP  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_FALLBACK_HEAP_ID=GRALLOC_USAGE_PRIVATE_ADSP_HEAP # Don't Care  
        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=GRALLOC_USAGE_PRIVATE_UNCACHED #uncached  
endif  
......  
       上述Makefile脚本片段会根据TARGET_BOARD_PLATFORM的值不同而设置不同的LOCAL_CFLAGS值，以便可以为目标设备编译出正确的HAL模块来。
       这一步执行完成之后，也就是编译完成之后，我们就可以在out/target/product/find5目录中看到两个文件：recovery.img和cm-10.1-xxxxxxxx-UNOFFICIAL-find5.zip。其中，recovery.img是Recovery文件，而cm-10.1-xxxxxxxx-UNOFFICIAL-find5.zip是ROM文件。有了这两个文件之后，我们就可以参照前面的介绍，将它们刷入我们的OPPO Find 5手机上去了。当刷入完成，并且可以正常运行之后，现在我们的手机上面运行的Recovery和ROM都是我们自己亲手打造的了！

       至此，我们就介绍完成CM的刷机过程和原理了，是不是觉得自己亲手去编译一个ROM是一件很容易的事呢？其实不然。我们上面编译的ROM之所以这么轻松，是因为CM已经为我们做了很多的工作，那就是已经在CM源码服务器上准备好了所有设备相关的源码，也就是我们下载回来之后存放在device目录下的源码。如果我们手头上有一部CM官方不支持的手机，那么CM源码服务器上是没有对应的设备源码存在的，这时候我们就需要自己去开发对应的设备源码了。这是一个艰苦的过程，需要不停的调试、调试、再调试，也许要花上几周，甚至一个月来完成这个工作。当然，这个过程也是有一些经验和技巧可以参考的，具体可以参考CM文档：http://wiki.cyanogenmod.org/w/Doc:_porting_intro。这里就不再详述。

       最后，本文之所以选择CM这个第三方ROM和源码来讲解，是因为CM官方提供了很全面的资料供我们去学习如何基于AOSP源码来制作ROM，这样可以使我们少走很多弯路！另外，上面所述的ROM过程都是参考了CM官方文档的。更多的CM刷ROM教程，可以参考：http://wiki.cyanogenmod.org/w/Development。更多信息也可以关注老罗的新浪微博：http://weibo.com/shengyangluo。

 举报
罗升阳 博客专家 访问量 1203万+ 原创 188 博主更多文章>
Android ROM分析(1)：刷机原理及方法
y97523szb 10799次阅读 2011-05-28 17:26:00
Android编译系统详解(一)——build/envsetup.sh
thinkinwm 5182次阅读 2014-05-04 20:26:05
安卓ROM结构
sxycgxj 3167次阅读 2013-03-24 09:55:14
Android ROM包文件系统根结构分析
haoge921026 1459次阅读 2016-06-14 22:07:54
关于uboot fastboot 的一些原理分析
lqxandroid2012 3958次阅读 2013-03-20 09:46:16
Fastboot使用详解
ylyuanlu 44971次阅读 2014-03-01 10:36:08
老罗的ANDROID之旅---硬件抽象层学习笔记
pkjueying 1903次阅读 2013-10-10 10:17:40
Android ----制作自己的Vendor
yimiyangguang1314 18413次阅读 2011-03-22 15:36:00
降龙十八掌搞定rt3070 USB WIFI模块在android2.3平台上上网［基于x210开发板］
armeasy 6888次阅读 2011-12-23 10:11:21
[Android] build 流程
dearsq 531次阅读 2016-12-16 16:16:00
更多相关文章

CSDN
CSDN精彩内容推荐
查看熊掌号

===============================

热血江湖手游枪职业输出暴力，是个大家都喜欢的职业。下面为大家带来热血江湖手游邪派鬼枪攻略。
14
5 7 11 15
技能搭配

主动技能：枪刃乱舞，幻魔烈魂，血雨鬼泣，枪跃龙门！气功：怒意之吼，横练太保，以退为进，转守为攻！绝技：醉舞狂歌，这技能打boss和pk谁用谁知道！

宠物

宠物，有条件买龙猫，很不错的宠物，至于咕咕鸡看个人，想要排行就买，平民完全没必要！培养三个，一个龙猫，一个火龙，一个狼！之前听说火龙后期没用，反正我不觉得，最起码挂机用起来很OK！

坐骑：

1.黑马一定要买，有能力老虎也要买，因为坐骑战力都是直接加到人物的，还有关键的洗练属性！

2.至于带什么出战，唯一的区别就是坐骑主动技能，我带的是白马，因为老虎碎片不够升星，不知道老虎技能，以后再考虑！

3.坐骑洗练，我觉得洗练是攻击-暴击-命中-防御-气血-其他！可能我理解有误，但是攻击是必须的，洗练没有技巧，完全看脸！

战力提升：

有能力充到v5 最好，挂机不错，而且能买成长礼包，挺不错的！或者v9因为可以买试炼次数，长期下来经验太多！神豪随意！

前期不要买强化石，除非你特别豪，反正我加起来买了40个中级就收手了！因为魔王也会出，我现在四个8，两个7！勉强不算差吧！前期最主要就是等级，有条件多挂机！

生产等级每天也可以做一下，紫色装备直接卖，不要分解，材料没用，生产等级我主要做初级宠物经验丹，因为要能量少，而且材料也好弄，后期生产等级绝对有用的！

宝石和大部分游戏一样一般都带攻击，气血，防御，不过我自己各自带了个命中，暴击，闪避！可能不对，但是挺好用的！

需要注意的就是宝石一到三级有能力直接买三级宝石，比你升级便宜很多！一级二级直接出售换能量！会省挺多的！

反正我也是这么提升的，没什么别的隐藏东西！暂时就想到这么多！

击杀魔王：

如果有条件一定要参加，一定要参加，一定要参加，重要的事情说三遍！基本上我们装备产出都在这了，而且是不绑定的！

我打了三天，还不是一直打，因为有工作，已经卖了5000多元宝！所以一定要参加！

宠物有龙猫用龙猫，没有就用火龙！给大家科普下，没事尽量自动然后点冷却好的技能，伤害会多不少！

我玩枪主要就是打这个给力，一般排行第一第二！这游戏职业不怎么平衡！枪，剑亲儿子，弓，刀后妈生的！医生是丢掉的孩子……

附上我交易图，免得有人不信……

材料兑换：

前期需要换，买的东西：

1地魔之眼碎片，前期帮贡全部换地魔之眼碎片，击杀魔王也会掉，最快速度把这个神兵弄出来，你会发现很多材料容易不少！我第三天晚上出的，全部宝箱都是我的...

2正邪功勋旗子，选择邪派最大的痛苦就是正魔战场排队一晚上进不去...这时候你必须买旗子、可以换很多好东西，而且这个不是消耗功勋换东西，而是你达到多少功勋，刷新出来的全能换！

3.五绝碑文碎片：提升五绝等级，我主升怪乞，因为他给神兵弓碎片！

竞技场：宠物碎片

帮贡：地魔之眼碎片，气功书！

劫镖帮贡：优先称号！

会武：有老虎坐骑优先老虎坐骑碎片！没有就换自己需要的坐骑碎片！
-------------------------------
1.气功：打魔王要的带的气功(破甲刺魂丶怒意之 吼丶以退为进丶横练太保)

2.技能：技能的话带(威凌天下丶枪刃狂舞丶疾风天狼破丶嗜血天狼击，嗜血天狼击是血量低于70%伤害最终翻倍，所以打魔王先把血狼降到70%以下)绝技带(醉舞狂歌)打魔王不要先开，第一次火龙刀变身完在用。

3.神兵：神兵的话打魔王的时候先去刷一波小怪把怒气刷满，魔王一出直接开神兵。

神兵第一次变身 先用火龙刀，如果魔王血掉的慢可以开3次神兵，第二次还是变火龙刀打，(这个要按每个区的情况来开，有些区BOSS是变身不了3次，当然装备有怒炎增加怒气的除外)第三次神兵用神枪，神枪的变身很重要，要在魔王还剩2条血的时候才开，不能提前开也不能迟了开，这时候开配合天赋五烈神枪伤害爆炸，也是打伤害主要输出。

还有神兵带的4个技能一定要神满，4个技能点满你会发现你打魔王的输出会提升一大截。(注意：打魔王要把设置里挂机设置自动野外地图神兵变身关掉，不然会自动变身，控制不来时间。VI5以上会自动开的。所以要手动关掉)。

4.宠物：龙猫配合第一次变身火龙刀打，第一波火龙刀快结束的时候进攻号角也可以用了，号角用了立马切换宠物小雪狼打怒气，为第二次神兵变身刷怒气。

怒气刷满了就切回龙猫，因为龙猫打的输出很高。注：(宠物自带的4个技能优先升级龙猫然后是小雪狼，兽灵丹建议 拍卖行宠物里购买，比商城便宜很多)我以前都是商城买的坑了很多元宝。

5.坐骑：坐骑出征(乌骓宝马)优先升到3星带2个孔装备后天骑术(战如熊虎丶铁马金戈(有钱的土豪可以升满5星带人马合一))。

坐骑洗练：枪优先洗出(攻击丶暴击丶其次命中，追加伤害(追加伤害要点开第四个洗练孔才能洗出来))其他属性看个人元宝充足洗，有钱就固定前面说的，元宝不充足洗出橙色或者红色的可以不洗了。

6.强化和升级：升级的话平均升，基本跟等级升，如果升级服不够，优先升(武器 丶戒子丶鞋子)。其他看升级符的富裕来点。

强化优先强化(武器丶护腕丶戒子，)平均升，其他平均跟着升。升级符和强化不要商城买，完全没必要的，每天试练副本(地下宝藏会掉落)足够升级和强化了。(土豪有钱可以去商城买来点强化，毕竟强化到后面加的属性很可观的)

7.内甲： 内甲有玄阴丶烈阳丶太虚。枪选烈阳就行，烈阳加的攻击很猛!内甲升级主要靠试练副本里的(冰原激斗)掉落的材料来升级(土豪可以直接商城买材料升级满级(大概要元宝4W-5W元宝可以一次性升满)

内甲天赋加点个人加法(强攻丶怒炎丶撩切)剩下的因为我也没点到也没试过，所以暂时不知道怎么点，靠大家补脑了!

8.绝技：五绝试练，优先第三个乞丐，出(醉舞狂歌丶和神兵玄武破天弓（注：这把神弓PK打架一流）)

声望优先打每五关的BOS掉落的声望物品比较多，当然关数越高的，掉落越多的。(还有商城土豪可以买每天限购10个的五绝碑文碎片 每个100绑定元宝 一个200点声望)

9.PK：这游戏PK其实也没什么说的，对枪来说，目前基本都是不是你秒我，就是我秒你，没啥技术好言!

PK带的技能和上面说的一样， 气功就带(怒意之吼丶乾坤 挪移丶以退为进丶横练太保)，绝技(带醉舞狂歌注：该技能免疫6秒控制，满级10秒!)因为枪怕控制所以必带。

神兵在没有出玄武破天弓的时候就带彼岸花。PK坐骑建议带老虎，老虎先天技能加命中，后天骑术建议带(马踏环铃、百毒不侵’)老虎没三星有二个孔可以带追风坐骑。

10.势力战：关于势力战很多人都说正派不行，正派总是说输，其实是很多人不会玩，进去都是自己玩自己的。.势力战个人建议帮会或者整个区找战力不是很低的组队进去，只要不是碰到对面变态级土豪大神基本不会输。

首先进去，优先把左右2边小雕像打掉，然后中推中间的大雕像。最后集体推对面水晶。势力战里面是优先推塔的，杀人是其次，推掉一个雕像分数给的很多的比你杀人多，如果你推掉一个水晶，比大神杀30-40个人的分都多，因为里面是按排名给功勋的，也是目前功勋获得的主要来源。(除了势力战获得功勋还有就是商城可以买，土豪专属商城)。

11.试炼副本：试练副本里的试练之地每天必须打，要升级必须打，V9可以购买一次.V13可以购买2次 剩下的试练副本，看个人元宝情况购买。

12.帮派拉镖：每天下午2点到3点和晚上7点30到8点30，拉之前要看下帮会祝福满没满，没满自己有经济可以点下，或者叫帮会土豪点，加成满的经验是多297%!当然小帮会就不多说。

13.帮会自创武功： 个人每次是劲点满(加伤害的)，御点满(点的越高冷却时间越短)自创10级以后会多个追，追点满(中间的控)，剩下的随便点，其实也就剩下一点可以点其他的。至于能不能出优，就看个人人品的，这是看运气出的。

14.限时活动：每天限时活动必须要做的，(正义之心，正邪道场，秘宝矿洞，江湖告急)(不是每天都有的，是分开天数的)

15.还有新区的一个活动，征战天下达成每个目标给的材料很多的，必须做的!

16.新区成长基金，如果想玩下去建议必买

还有新区的，挂机看个人战力挂，最佳是挂比自己高10级的怪经验多，前提你能扛得住!
-----------------------------
枪客，热血江湖手游中的高暴击高伤害输出职业，到后期技能有很多，只能用4个，那么枪客技能选择哪些好？怎么搭配好呢？

￼

1转之前的就用基础的4个职业不用多说；20级1转之后，用两个新技能替换“鹰击长空”和“天神万钧”2个基础技能；

【2转pk】

枪跃龙门+1转的2个技能+2转的伤害技能

【2转pve】

枪刃狂舞+1转的buff技能+2转的2个技能

【3转pk】

1转的Buff技能+2转的伤害技能+3转的2个技能

【3转pve】

枪刃狂舞+1转的Buff技能+2转的Buff技能+2转的Buff技能

因为部分技能名称还未知，所以后续可能再修改，大家主要看好技能的效果选择就行。比如pk就多用伤害+控制技能；pve刷怪打副本用群攻的，加buff的技能。




========================================
说法1：
电喷汽车说明书上说：拖档（带档滑行）电脑（电喷）会自动断油，而空档时发动机为了维持怠速反而要耗油，所以带档滑行要省油些。如果是化油器汽车空档就省油些。
从供油逻辑上给你说一下空档滑行和带档滑行省油的的原因。
这先说一下吧，这得从发动机的供油方式说起，现在社会上行驶的汽油发动机的车型主要有两种供油方式，老车化油器供油方式，新车电控燃油喷射方式。化油器供油方式是靠发动机进气时形成的低压将燃油吸入燃烧室进行燃烧的，控制油量的方法是用 量孔，量孔的截面大小决定了吸进去的油量，靠节气门控制空气的
进气量，空气与汽油混合后进入燃烧室燃烧做功，还有其他一下什么怠速，急加速，全负荷供油等辅助系统就不说了。电控燃油喷射方式，简称电喷，它分为单点，多点，顺序的多种方式，这里就说一下他的工作原理，它和化油器的供油方式完全不一样，它是靠喷油嘴向进气管喷油来供油的，喷油嘴由电脑控制电磁阀的电流来控制喷油嘴开启的时间，也就控制了喷油量，同时根据发动机各个传感器传来的信号修正喷油量，达到精确控制的目的。
再说一下在带档和空档两种情况下，两种供油方式的处理办法。
化油器，不管空档，还是带档，只要有气体通过，就会有相应的汽油进入发动机燃烧，带档是发动机被车辆推着走，发动机的转速也不低，所以尽管节气门关闭了，空气进入量被限制了，但是发动机进气时形成了很大的低气压，汽油还是很多被吸入了，这就是很多老车带档一加油就放炮，就是因为很多汽油在发动机里没有燃烧干净，进入到排气管里面燃烧造成的。但是空档就不一样了，空档是怠速，肯定要比这样省油，所以，化油器的汽车空档是省油的，带档一点也不省油。
电喷的发动机，空档是怠速供油，带档有两种情况出现，一种是车辆在高速行驶时，突然电脑检测到节气门回位到带速位置，它认为进入带档滑行状态，为了燃油经济性，电脑会停止喷油，完全让车反推着发动机运转，电脑检测到车辆行驶速度降到规定值后，电脑控制喷油器继续喷油维持发动机的运转，这期间你加油它也会立即恢复供油的，这个就是带档滑行能省油说法的根据。可是要说明的一点是一般情况下，例如你行驶的速度是60公里你带档滑行，这时这个功能不会启动的，因为速度低时，发动机完全停止喷油会造成坐车的，如果恢复不了供油刹车也受到影响的，所以厂家设定的速度都很高，平时的这种低速行驶根本不省油。所以电喷的发动机高速带档滑行省油的，低速带档滑行没有空档滑行省油。
所以说化油器的车空档省油，电喷车要好好利用高速它带档滑行省油，低速空档滑行省油的特性才能达到最省油，呵呵！
说法2：
给你说简单一点，
1：空档后并不省油，因为带档滑行节气们就关闭了，节气们关了就说明不烧油了，听着很大的声音，那只是轮子带动变速箱的声音。除非你把钥匙关了摘档滑行，我得一个卖车朋友参加夏利省油比赛，就是这样，半升油跑了20多公里，这个有据可查。
2：空挡的危害，刹车！！！有人证实过100迈的速度一脚刹死，有档和无档，好像多少米记不清楚了。差20米好像是。
经常开车脚上应该有感觉啊。
3：我自己长时间总结的经验，如果你的车用了一段时间后，巧不巧说不定哪天。带速伐脏了，行车滑行的时候突然熄火了， 车熄火了，方向和刹车就没有助理了，如果开着一辆没有方向，没有刹车，是什么样子啊。自己想象后果
4：补充：损坏变速箱，长时间滑行变速箱就不供油了，变速箱就是干摩。
请大家一定带档滑行，不要空挡。 我以前也是空挡滑行，改了半年也改过来。
说法3：
电喷车空挡滑行省不了多少油！电喷车的基本原理是具有“减速断油”的功能，先看带档的情况：例如你的发动机在4000转/份高速运转，突然松开油门，电脑会自动停止向汽缸供油，缸内也没有燃油燃烧，不过不摘档，车辆带着发动机高速转，等转速降到1300转/分时又自动恢复供油。在从4000-1300转/分的过程中没有燃油消耗，也能滑行很长时间，是省油的，由于不空档，对于行驶来说也是安全的。再看空档的情况：如果你松油门，空档，在4000转时发动机因为没有动力带动将迅速降至1300转，也就是一秒左右的时间。到1300转/份是又自动供油，相当于化油器车的怠速状态，一秒多的时间不供油，你能省多少油呢？虽然你滑行的距离稍远一点，但是发动机基本上是始终供油的，所以不省油，正向楼上所说的那样也不安全。即省不了多少油，又不安全，还不如充分利用它的优势，带档滑行为好。哈哈！
说法4：
建议不要空档滑行
1、空档滑行不是省油的有效方法。
2、安全问题，现在的家用轿车基本都有液压方向助力，并且采用油压刹车。在这种情况下如果空档滑行，一旦在你不注意的时候由于某处问题导致汽车熄火，汽车的方向助力会把方向锁住，同时刹车很可能实效，非常危险的。
介绍我开车省油的方法
1、根据车款适当使用车胎气压，气压不够会很废油。
2、保持匀速，行车是尽量不要急加速（飙车除外）－_—！。
3、掌握换挡时机，高转速无疑会增加油耗，但长期低速换挡无疑会增加发动机堆碳，影响混合气体燃烧，也会增加油耗（捷达建议在三千转左右换挡）
4、定期保养、保持喷油嘴清洁。
5、避免高速行驶，首先是不安全，其次是你的车经济油耗应该是90Km/h等速。车速高于120Km/h油耗肯定高很多。
说法5：
怎么会省油呢？空挡省油是化油器时代的事情了。
针对化油器的车，在空挡状态时，属于怠速状态。而化油器发动机不存在不喷油时段的情况，所以化油器车最省油的情况在空挡滑行时。
而电喷车为什么空挡不省油呢?因为在带挡滑行时，车轮由一系列的机械与发动机连接，可以带动发动机运转，在条件合适的情况下，发动机由于有了车轮动力运转，当然就不再需要汽油燃烧运转。这时，行车电脑就控制汽车不再喷油。
而电喷车空挡滑行时，由于没有了上述条件，发动机是在怠速运转。
楼主可以想想，到底是带挡滑行完全不燃烧汽油比较省油，还是空挡滑行燃烧汽油省油呢？
不过这只是理论。在实际中，想要做到真正省油还是需要诀窍的：转速1200以上带挡滑行，当转速低于1200了，大部分发动机都会重新开始喷油，这样油耗就相对空挡就增加了，这时应该选择摘档，让车空挡滑行。当然了，一定要注意安全，特别不要在湿滑的下坡路这样做。
最后，严重鄙视不会回答问题就拿安全说事的。
说法6：
电喷车下坡时挂档省油。电喷车的发动机有三种状态：怠速、加速、减速。怠速和加速状态下发动机是喷油的，而减速状态下，发动机是停止供油的；当你下坡挂上空档后，车载电脑会认为此时发动机是在怠速状态，所以挂空档时发动机仍会供油。
所以下坡时尤其是大坡长坡时应该挂档下坡，一是坡大速度够，坡长滑行时间长，发动机在长时间里是停止供油的；二是挂档下坡由于发动机制动，所以比较安全，在发生紧急情况时容易减速制动；三是可以保护制动系统，由于挂档时有发动机制动，所以可以减少制动系统的负荷，延长制动系统的寿命。
但是，发动机停止供油是有条件的，它是在某一转速以上才会停止供油，如果转速低于某档位的标准转速后，发动机又会恢复供油来维持该档位的转速；比如说，一辆车四档的标准转速是2500转，当下坡时开始车速快，发动机转速就高于2500转，这时发动机就停止供油了；但到了坡底了，车速变慢了，转速低过2500转，这时发动机就会恢复供油了。
所以要不断的累积经验，来判断自己的车子各档位的转速和车速的关系，在合适的速度挂合适的档位。
说法7：
高速时挂档滑行省油，而低速时是空挡滑行省油，因为：高速的时候是车带动发动机转，而低速的时候是发动机带动车转。
电喷发动机，当电喷发动机的ECU监测到一定转速和车速的状态,(每一种车具体参数不同)这时如果还有档位信号，并且监测到油门放开(节气门关闭)就会停止喷油.如果空挡就会认为是怠速状态,还是要喷油的.
、带档滑行时，当转速低于约1000转－1400时，转用空挡滑行更省，因为这时候关闭的油门会重新打开，不如空挡滑行阻力更少。
说法8：
电喷车空挡滑行并不省油，挂高档滑行才省油，因为电喷车当你挂档滑行的时候，电控单元会认为是利用发动机制动，将停止喷油，直到你再次踩油门，或者是发动机转速过低时才会再次喷油，但是当你空挡滑行的时候的时候发动机是怠速运转，电控单元会继续喷油，这样是最费油的
说法9：
对一般车来说：3000转以下是空档滑行好，3000转以上时，无所谓，电脑会自动断油的，到3000转时又自动供油，相对来说，空档省油，因为挂挡是发动机有阻力，减少滑行距离，还要加油跑。
一共三个实验！
一直对很多人说的电喷带档滑行不喷油非常怀疑，不喷油，难道车不灭么？？？！！！现在终于有人做小白鼠了！
试验车型：5v捷达、2v捷达、1.6/1.8BORA、2.4/2.5切、2.4佳美
试验设备：全功能检测仪和喷油嘴检测示波器。
试验里程：单车100公里，共计600公里
试验路况：城市、国道混合路况
试验目的：验证争论很久的带档还是空档省油问题
试验过程：首先每辆车都加满油，前五十公里为频繁空档驾驶，后五十公里为所有路况带档驾驶。
经过2天的实验后，得出以下结论。
1、在空档滑行时，发动机的喷油脉宽为最小怠速喷油脉宽。
2、带档滑行时，并未出现传说中的断油情况，而且其工作喷油脉宽远大于怠速喷油脉宽。
3、参加试验的日系车型的怠速瞬时油耗显示为无穷大，其显示结果误导了很多人，因为带档时其显示的油耗小于怠速油耗。
4、急刹车废油原因有两个，第一损失了动能；第二发动机会加大喷油量，以保证发动机不熄火。
最终试验结论：空档滑行省油
空档滑行省油的科学研近来，广播、电视、报纸、网络等各种媒体及一些“专家”，纷纷发表言论，称现在的电喷车空档滑行是不省油的！真是这样吗？通过我的研究试验，结果是：空档滑行真的省油！为什么？有科学根据吗？经过一段时间的研究，找到科学的依据：能量守恒定律！
我现在的车是帕萨特领驭1.8T手动豪华型，2006.4.1.购买，具有行车电脑，可以实时显示油耗等信息，这为我研究行车省油方法提供了条件。
由于我的笔记本电脑坏了，近期才修好，所以这个报告现在才完成，不过这也让我反复的验证现在的研究
结果，确保研究结果的正确性（请大家看完后再拍砖）。
以前我开的捷达王7年，行驶了26万多公里，我经常空档滑行，以图省油，然而看了有关专家的“理论”，也通过一些土办法验证了：电喷车不摘档滑行时是断油 的（一定速度以上），但有一次，我的车做了三保，修车师傅要求我适当注意磨合，当时我跑长途，采用跑一段、滑行一段的方法，结果算下来，平均油耗：5.8 升/百公里，而我平时跑高速一般在6.3——7.0升/百公里！当时我就觉得空档滑行省油，可惜条件不具备，没办法开展具体的研究。换车时，我特意选择有 行车电脑的车（开始时选定“别克君威”，
由于没有行车电脑等配置而放弃）。
研究工作先从道路测试开始，我认为行车电脑中最有用的是：瞬时油耗及平均油耗。
在同一路段，两次行程的油耗分别记录（近期很忙，经常跑长途，我的领驭两个月跑了9230公里了），以下是记录情况：
第一组： 全程空调，车载司机一人，上高速前平均油耗清0，长治——太原，限速：每小时110KM、80KM
、70KM、100KM等：
1、全程基本不摘空档滑行，采用巡航定速功能，全程213.2KM，平均油耗：7.1升/百公里 用时2小时20分；
2、全程有机会就空档滑行，213.5KM，平均油耗：6.3升/百公里
用时2小时22分；
第二组： 全程空调，车载司机及乘客共两人，上高速前平均油耗清0，太原——原平，限速：每小时90KM、100KM、110KM等
1、基本不摘空档滑行，采用巡航定速功能，全程93.2KG，平均油耗：7.0升/百公里
用时57分；
2、全程有机会就空档滑行，93.3KG，平均油耗：6.4升/百公里
用时59分；
从以上数据可以明显看出，空档滑行时，是绝对省油的！特别是去长治，由于坡路较多，节油效果更加明显。原因是下坡路滑行效果更好，（当然，要注意安全，控制好车速，当速度超过限速10——20公里时，挂上5档进行发动机制动，速度低到限速值时再摘空档滑行）。
另一种测试：
在平直的高速路上，使车加速到90公里/小时，通过滑行使速度降到40公里/小时（因为挂5档、车速到40公里/小时后，发动机的转速接近1200转，发动机的电脑为了防止熄火，是要开始供油的，这以后的滑行，不能再享受0升/小时的“省油”方式了，所以选这个速度）。
挂5档滑行，使车速降到40公里/小时，大约能滑行500米左右；
如果空档滑行，使时速降到40公里/小时，大约可滑行1000米左右。
空档滑行使行驶距离增加了一倍。挂档滑行时，这500米路程的油你是省下了，可你差下的500米距离不用
油了吗？
试验证明了空档滑行省油，有理论依据吗？
首先，我们来分析省油的原因，我们大家知道，车的行走是靠发动机燃烧燃油旋转产生的动力，换句话说，必须烧油才能使发动机旋转，而发动机旋转的速度是和燃 烧燃油的多少有关系，旋转的速度越快，烧掉的燃油也越多，大家都知道：在停车的时候，你要提高转速，必须踏下油门加油，也就是说转速的提高，需要增加能 耗。我的车载电脑显示：在停车、开空调的情况下，800转/分钟时，油耗 1.2升/小时，如果要使转速保持在2500转/分钟，油耗为 2.8升/小时。
那么我们的空档滑行与不摘档滑行和发动机转速有关吗？有！
大家知道，空档滑行时，发动机要维持在约800转的怠速上，要消耗一定的能量；
而挂档滑行时，在一定的转速以上，发动机是断油的，也就是不耗油，这时，发动机一般要维持在1200转以上（档位、速度不同，发动机的转速不同，但发动机 转速必须大于1200转，否则，发动机电脑是不会断油的），那我为什么说他不省油呢？原因出在发动机的转速上，要维持发动机1200转以上的转速，势必要 比800转的转速消耗更多的能量，也就是：转速越高，消耗的能量越大！那么，这个能量是哪里来的呢？
它只能是由汽车的动能转换回来的！就是先前加油提速，使车速达到一定值——汽车有了一定的动能，松开油门后，在发动机转速大于1200转以上时，发动机电 脑断油，这时，汽车的一部分动能，就转化为使发动机旋转的能量，根据大家都知道的能量守恒定律，这部分能量的消耗，必然会减少汽车滑行的距离和速度，你要 到达的目的地是一定的，它减少的距离和速度，你需要消耗另外的能量——燃油——来完成，所以挂档滑行的油耗必定比空档滑行要大。
换一个角度来研究一下，从长治到太原，挂档滑行（140分钟），发动机的转速始终在2500转/分钟以上，2小时20分里，发动机总的转数 为：2500*140=350000转；而采用空档滑行时（142分钟），由于有一段时间是空档，发动机的转速是800转，如果空档滑行的时间按总时间的 1/10计算，则发动机总的转数为：
2500*128+800*14=320000+11200=331200转，也就是说，在整个行程中，发动机在空档滑行方式下，比挂档滑行方式少旋转了18800转，既然发动机的总转数少了，当然消耗的燃油就少了，那么省油的原因就很清楚了。
那么为什么外国人要设置挂档滑行时的断油呢？他有什么作用吗？
这在前面大家可能已经看到了，我在空档滑行速度过快时，立即挂上5档，利用发动机断油的功能，既降低了速度，又不消耗燃油，这比踩刹车来减低车速，要节省燃油。
另外，在城市里行车时，由于交通情况复杂，经常要加速、减速，合理利用挂档滑行，会起到很好的节油效果。例如，绿灯亮时，前方车辆鱼贯而出，你也不能行驶 的太慢，否则，与前方车辆之间的空当过大，其他车辆会插进来；到下一个路口的信号灯前，你又需要减速，这时尽量利用挂档滑行来减速，必要时，可换入低档， 以增加制动力，减少滑行距离，尽量少用刹车，因为刹车是绝对消耗能量的。
以上研究的目的，不是鼓励大家一定要用空档滑行，只是要澄清一个大家所认为的“省油”方式的误区。
考虑问题要全面一些，不要一说电喷发动机，就都说挂档滑行省油，(前些日子看见一篇文章，一个很有经验的老司机说：“在合适的时候空档滑行以节省燃油”， 得到很多人的嗤之以鼻，很是看不惯！)；对于空档滑行的利用，我个人认为，这种方式要因人而异，新手要慎用，驾驶熟练者完全可以充分利用，毕竟利用发动机 做安全制动的作用是有限的，只要你在驾驶过程中，认真观察、谨慎驾驶，及时采用合理的操作，才是最安全的。
另外，发动机的转速减少，必然减少了发动机的磨损，应该对发动机有好处吧？他还使车辆高速行驶中的发动机有劳有逸，是不是可以减少发动机长期工作在恶劣情况下的损耗呢？
至于城市里驾车节油，我有几点体会：
1. 要看的远一些，及早做出判断和处理，例如：在远处看见路口红灯亮起，要根据车速、距离及红、绿灯变化的大概时间，采取空档滑行、或挂合适的档位滑行，使车 辆平稳的到达路口；如果看见绿灯，要及时加速，争取通过，否则，你慢悠悠的过不去，在路口等两三分钟，也是要消耗燃油。
2. 选择较好的路线，在出行时，就要想好，那条路或路口，当前这个时间是否车多？是否放学时间？是否路过学校？上班时间怎么走？下班时间从哪过？哪条路右转弯 多（我们这里大部分路口红灯可以右转弯）？哪条路左转弯多？什么地方钻小胡同？什么地方走大路等等，然后选一条合适的线路，用最少的时间、尽可能短的距 离，到达目的地。在市内，有速度高的路就不要选速度低的道路。
3. 在确保安全的情况下，尽可能的使用空档滑行，在需要制动时，尽量使用挂档滑行的方法，必要时，才使用刹车，这样才能最大限度的节省燃油。
我驾车就是采用这种办法，我得帕萨特领驭1.8T手动豪华型，在开空调的情况下，一般跑长途，油耗控制在6.5升/小时左右，太原市内不超过9升/小时（我在市内开车，其实不很温柔，因为我们这儿的交通，太温柔了是要受欺负！）
行车利用空档滑行肯定是省油的！当然也不能一直滑行，如果车速已经很慢了，你还滑行，那就不一定省油了。
本人以前一直开化油器的车，经常是空档滑行，当然比较省油，但在下坡时考虑安全，还是带档滑行的。
尽管此前多次驾驶过电喷车，从来没有考虑过省油问题。
最近刚买了一辆经济型SUV，491QME发动机。说明书上标明经济时速是7.8升/百公里（50公里/小时）。根据491QME发动机的“总功率实验曲线”可以看出，它的负载燃油消耗量位于3000转/分钟坐标点处。
我们都知道，带档滑行距离近，而空档滑行距离远。这只是定性分析。省油的基本概念应该是，行驶相同距离，耗油量越少越省油。为了比较精确的试验论证究竟带 档滑行省油还是空档滑行省油，我们在平坦的路面上试验了一下，试图用试验与定量分析的方法,具体论证这个问题，欢迎各位大侠批评指正。
一、已知数据：
车辆加速至50公里/小时（发动机转速为3000转/分钟），空档滑行至5公里/小时，滑行距离为2000多米，滑行时间约3分钟多。
车辆加速至50公里/小时时，带档滑行至30公里/小时，滑行距离约1000米。根据转速表判断此时发动机会
自动恢复供油（1200转/分钟），速度由30公里/小时降到5公里/小时。总共滑行时间4分钟多。
491QME发动机怠速为800转/分钟；
491QME发动机空载怠速油耗是1.2升/60分钟===20毫升/分钟；
491QME发动机负载怠速油耗（5档）是12.48升/百公里；
经济油耗是7.8升/百公里====78毫升/公里；
二、计算结果：
1、空档状态时，滑行2000米，空载怠速油耗是60毫升。
2、带档滑行时，前1000米不耗油，后1000米为负载怠速状态，油耗率（5档）为12.48升/百公里（由491QME发动机“总功率实验曲线”查 出），这样后1000米实际耗油量为124.8毫升。此时油耗高的真正原因是发动机负载怠速或低速油耗高（5档是12.48---15升/百公里），装备 有电脑自动显示瞬时油耗的车辆上可以看出。
3、行驶相同距离，带档滑行耗油量是空档滑行耗油量的一倍以上。
三、结论：
平坦道路时在不影响安全前提下，空档滑行比带档滑行节省一半油以上。
下坡道路时尽可能低档位带档滑行，以维持发动机高转速断油状态，并保持发动机制动此时比空档滑行更省油







